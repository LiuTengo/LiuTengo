<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++多态</title>
      <link href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E5%A4%9A%E6%80%81/"/>
      <url>/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1>静态多态</h1><p>静态多态通过重载实现多态</p><h2 id="重载函数">重载函数</h2><p>函数同名，参数不同类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is Func1(int), Parameter = &quot;</span>&lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func1</span><span class="params">(<span class="type">float</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is Func1(float), Parameter = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载运算符">重载运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream o,<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">return</span> o&lt;&lt;a.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>动态多态</h1><p>动态多态通过虚函数实现多态。使用动态多态必须<strong>通过指针或引用</strong>才能调用函数。</p><h2 id="虚函数">虚函数</h2><h3 id="虚函数的声明和调用">虚函数的声明和调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">a</span>(<span class="string">&#x27;A&#x27;</span>)&#123;  cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is A vFunc1(int), Parameter = &quot;</span>&lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>():<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is C vFunc1(int), Parameter = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* c = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    A* a = c;</span><br><span class="line">    c-&gt;<span class="built_in">vFunc1</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C c = C();</span></span><br><span class="line">    <span class="comment">//A ac = c;</span></span><br><span class="line">    <span class="comment">//ac.vFunc1(2); 输出：This is A vFunc1(int), Parameter = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">This is C <span class="title">vFunc1</span><span class="params">(<span class="type">int</span>)</span>, Parameter </span>= <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="构造函数与虚析构函数">构造函数与虚析构函数</h3><ul><li>构造函数不能被声明为虚函数。调用虚函数需要借助虚函数指针，虽然虚函数表的建立是在编译阶段，但在实例化后才能知道虚函数指针的具体地址，而父类的构造函数在实例化子类后调用，子类需要知道父类的虚函数指针。如果声明为虚的，则子类不知道父类的虚函数指针，无法调用虚函数。</li><li>析构函数可以被声明为虚函数。常见于释放父类的成员指针等。</li></ul><p>使用父类指针指向子类对象，在释放指针时，不会调用子类的构造函数，造成子类的成员不能释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* a;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is A vFunc1(int), Parameter = &quot;</span>&lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>():<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is C vFunc1(int), Parameter = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">C</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* c_ptr = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    <span class="keyword">delete</span> c_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Create A</span><br><span class="line">Create C</span><br><span class="line">Destroy A</span><br></pre></td></tr></table></figure><p>将A的析构函数声明为虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* a;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is A vFunc1(int), Parameter = &quot;</span>&lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>():<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is C vFunc1(int), Parameter = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* c_ptr = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    <span class="keyword">delete</span> c_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯虚函数与抽象类">纯虚函数与抽象类</h2><p><strong>纯虚函数</strong>相当于C#中接口中的方法，其子类必须实现该方法，否则不能通过编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">a</span>(<span class="string">&#x27;A&#x27;</span>)&#123;  cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>():<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">C</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* c = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//Error 报错：E0322不允许使用抽象类类型的对象，纯虚函数没有强制替换项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>():<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vFunc1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pure Virtual Function of C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">C</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>抽象类</strong>使用abstract关键字，使用该关键字就不能实例化的类。通常将一些包含纯虚函数的类加此标识以明确区分。</p><h1>虚函数的底层原理</h1><h2 id="单继承">单继承</h2><p>虚函数通过虚函数表和虚函数指针实现。</p><h3 id="虚函数表、虚函数表指针的生成">虚函数表、虚函数表指针的生成</h3><p><strong>结论</strong>：</p><ul><li>编译阶段，生成虚函数表并为生成虚函数表指针做准备。</li><li>但虚函数表、虚函数表指针、虚函数指针的具体地址是在程序运行时生成。</li><li>虚函数表是静态的，每个声明了虚函数的类中只有一套虚函数表及虚函数表指针。</li></ul><p>只要在一个类中声明了一个以上的虚函数，编译器就会在编译期间为该类生成一个虚函数表。这个虚函数表是<strong>静态的</strong>，实例化多个对象可以看到每个对象中的虚函数表指针、虚函数表及虚函数指针的地址都是相同的。</p><p>编译器如何在编译期间为该类生成虚函数表呢？</p><p>具体做法编译器在编译期间在构造函数中插入为虚函数表指针赋值的语句。但具体的指针地址是在运行时动态生成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(B): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(B): <span class="number">1</span> <span class="comment">//在A中添加普通函数，也是输出1</span></span><br></pre></td></tr></table></figure><p>在B类中声明虚函数后，实例化一个对象，并进行调试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: Func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(B): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Create B</span></span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(B)</span>: <span class="number">8</span></span></span><br><span class="line"><span class="function">Destroy B</span></span><br></pre></td></tr></table></figure><p>调试信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b&#123;...&#125;B</span><br><span class="line">-__vfptr<span class="number">0x00007ff7cd0bbed8</span> &#123;***.exe!<span class="built_in">void</span>(* B::`vftable<span class="string">&#x27;[4])()&#125; &#123;0x00007ff7cd0b159b &#123;***.exe!B::Func1(void)&#125;, ...&#125;void * *</span></span><br><span class="line"><span class="string">[0]0x00007ff7cd0b159b &#123;***.exe!B::Func1(void)&#125;void *</span></span><br><span class="line"><span class="string">[1]0x00007ff7cd0b1596 &#123;***.exe!B::Func2(void)&#125;void *</span></span><br><span class="line"><span class="string">[2]0x00007ff7cd0b1591 &#123;***.exe!B::Func3(void)&#125;void *</span></span><br></pre></td></tr></table></figure><p>输出显示B类占用内存大小8个字节，这是__vfptr指针的内存大小。</p><p>__vfptr指向一个<strong>虚函数表</strong>，故称__vfptr为<strong>虚函数表指针</strong>，其中存放着所有虚函数的指针。</p><h3 id="继承关系中虚函数是如何运作的。">继承关系中虚函数是如何运作的。</h3><p><strong>结论</strong>:</p><ul><li>父类指向（引用）了子类的对象时，子类复制父类虚函数表中的所有函数，构成子类的新虚函数表，同时分配一个指针指向该表。</li><li>子类覆写了父类的虚函数会覆盖掉父类对应的虚函数指针，而没有覆写父类的虚函数则指向父类的虚函数。</li></ul><p><img src="https://s2.loli.net/2024/07/31/bovGhsYSqKajtQk.jpg" alt="虚函数底层原理示意图" title="虚函数底层原理示意图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* number;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n):<span class="built_in">number</span>(&amp;n)&#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: Func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> number;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> n):<span class="built_in">B</span>(n)&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is C Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is CFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* b1 = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">0</span>);</span><br><span class="line">    B* b2 = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    B* c = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">20</span>);</span><br><span class="line">    C* c2 = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    b1-&gt;<span class="built_in">Func1</span>();</span><br><span class="line">    b2-&gt;<span class="built_in">Func1</span>();</span><br><span class="line">    c-&gt;<span class="built_in">Func1</span>();</span><br><span class="line">    c2-&gt;<span class="built_in">Func1</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试信息：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b1</span></span><br><span class="line">-b1<span class="number">0x0000021239979d20</span> &#123;number=<span class="number">0x000000fa490ffb18</span> &#123;<span class="number">20</span>&#125; &#125;B *</span><br><span class="line">-__vfptr<span class="number">0x00007ff77d2bbed8</span> &#123;***.exe!<span class="built_in">void</span>(* B::`vftable<span class="string">&#x27;[4])()&#125; &#123;0x00007ff77d2b159b &#123;&#123;***..exe!B::Func1(void)&#125;, ...&#125;void * *</span></span><br><span class="line"><span class="string">[0]0x00007ff77d2b159b &#123;&#123;***..exe!B::Func1(void)&#125;void *</span></span><br><span class="line"><span class="string">[1]0x00007ff77d2b1596 &#123;&#123;***..exe!B::Func2(void)&#125;void *</span></span><br><span class="line"><span class="string">[2]0x00007ff77d2b15af &#123;&#123;***..exe!B::`vector deleting destructor&#x27;</span>(<span class="type">unsigned</span> <span class="type">int</span>)&#125;<span class="type">void</span> *</span><br><span class="line">+number<span class="number">0x000000fa490ffb18</span> &#123;<span class="number">20</span>&#125;<span class="type">int</span> *</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b2</span></span><br><span class="line">-b2<span class="number">0x00000212399796e0</span> &#123;number=<span class="number">0x000000fa490ffb18</span> &#123;<span class="number">20</span>&#125; &#125;B *</span><br><span class="line">-__vfptr<span class="number">0x00007ff77d2bbed8</span> &#123;&#123;***..exe!<span class="built_in">void</span>(* B::`vftable<span class="string">&#x27;[4])()&#125; &#123;0x00007ff77d2b159b &#123;&#123;***..exe!B::Func1(void)&#125;, ...&#125;void * *</span></span><br><span class="line"><span class="string">[0]0x00007ff77d2b159b &#123;&#123;***..exe!B::Func1(void)&#125;void *</span></span><br><span class="line"><span class="string">[1]0x00007ff77d2b1596 &#123;&#123;***..exe!B::Func2(void)&#125;void *</span></span><br><span class="line"><span class="string">[2]0x00007ff77d2b15af &#123;&#123;***..exe!B::`vector deleting destructor&#x27;</span>(<span class="type">unsigned</span> <span class="type">int</span>)&#125;<span class="type">void</span> *</span><br><span class="line">+number<span class="number">0x000000fa490ffb18</span> &#123;<span class="number">20</span>&#125;<span class="type">int</span> *</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c</span></span><br><span class="line">-c<span class="number">0x0000021239979140</span> &#123;...&#125;B * &#123;C&#125;</span><br><span class="line">-[C]&#123;...&#125;C</span><br><span class="line">+B&#123;number=<span class="number">0x000000fa490ffa18</span> &#123;<span class="number">2099975544</span>&#125; &#125;B</span><br><span class="line">-__vfptr<span class="number">0x00007ff77d2bc028</span> &#123;&#123;***..exe!<span class="built_in">void</span>(* C::`vftable<span class="string">&#x27;[4])()&#125; &#123;0x00007ff77d2b15b9 &#123;&#123;***..exe!C::Func1(void)&#125;, ...&#125;void * *</span></span><br><span class="line"><span class="string">[0]0x00007ff77d2b15b9 &#123;&#123;***..exe!C::Func1(void)&#125;void *  //覆写了B的虚函数，一个新的虚函数地址。</span></span><br><span class="line"><span class="string">[1]0x00007ff77d2b1596 &#123;&#123;***..exe!B::Func2(void)&#125;void *  //没有覆写B的虚函数，和b1、b2的Func2()地址相同。</span></span><br><span class="line"><span class="string">[2]0x00007ff77d2b15d2 &#123;&#123;***..exe!C::`vector deleting destructor&#x27;</span>(<span class="type">unsigned</span> <span class="type">int</span>)&#125;<span class="type">void</span> *   <span class="comment">//覆写了B的虚析构函数</span></span><br><span class="line">+number<span class="number">0x000000fa490ffa18</span> &#123;<span class="number">2099975544</span>&#125;<span class="type">int</span> *</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c2</span></span><br><span class="line">-c2<span class="number">0x0000015be6f89610</span> &#123;...&#125;C *</span><br><span class="line">-B&#123;number=<span class="number">0x00000047dd93f718</span> &#123;<span class="number">-203680392</span>&#125; &#125;B</span><br><span class="line">+__vfptr<span class="number">0x00007ff6f3dcc028</span> &#123;***.exe!<span class="built_in">void</span>(* C::`vftable<span class="string">&#x27;[4])()&#125; &#123;0x00007ff6f3dc15b9 &#123;***.exe!C::Func1(void)&#125;, ...&#125;void * *</span></span><br><span class="line"><span class="string">+number0x00000047dd93f718 &#123;-203680392&#125;int *</span></span><br></pre></td></tr></table></figure><p>通过比较上面__vfptr中的虚函数指针地址，可以看到虽然c是B类的指针，但虚函数表指针已经是C类的指针了。子类覆写了父类虚函数的，会有一个新的虚函数地址。而没有覆写父类虚函数的，则指向父类的虚函数。</p><h2 id="多重继承">多重继承</h2><p>多重的单一继承同样符合上文的规则。依次类推即可</p><h2 id="多继承">多继承</h2><p><img src="https://s2.loli.net/2024/07/31/8R2u1b4welmB7zX.jpg" alt="多继承的虚函数底层原理" title="多继承的虚函数底层原理"></p><p><strong>结论</strong>：</p><ul><li>一个继承多个父类的子类会持有所有父类的虚函数表指针。</li><li>子类覆写了父类中同名的虚函数，则每个父类中的每个同名虚函数均会被覆写。</li><li>子类覆写了父类的虚函数，则覆盖对应的父类虚函数地址。否则，复制父类虚函数地址。</li><li>子类中新添加的虚函数会添加到最先继承的父类的虚函数表中。</li></ul><p><strong>实验</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* a;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is AFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AvFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is AvFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ABvFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is ABvFunc() in A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* number;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n):<span class="built_in">number</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))&#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BvFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BvFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ABvFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;This is ABvFunc() in B&quot;</span> &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> number;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> n):<span class="built_in">B</span>(n)&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ABvFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is  ABvFunc() in C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is CFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">MyVirtualFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is MyVirtualFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* c1 = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">2</span>);</span><br><span class="line">    c1-&gt;<span class="built_in">ABvFunc</span>();</span><br><span class="line"></span><br><span class="line">    C* c2 = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">3</span>);</span><br><span class="line">    c2-&gt;<span class="built_in">MyVirtualFunc</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c1</span></span><br><span class="line">-c1<span class="number">0x000001c7ad0f7c00</span> &#123;...&#125;A * &#123;C&#125;</span><br><span class="line">-[C]&#123;...&#125;C</span><br><span class="line"><span class="comment">//A</span></span><br><span class="line">-A&#123;a=<span class="number">0x000001c7ad0ebc30</span> <span class="string">&quot;A葺葳馫,&quot;</span> &#125;A</span><br><span class="line">-__vfptr<span class="number">0x00007ff7c5c7c038</span> &#123;OOPLearning.exe!<span class="built_in">void</span>(* C::`vftable<span class="string">&#x27;[4])()&#125; &#123;0x00007ff7c5c71569 &#123;OOPLearning.exe!A::AvFunc(void)&#125;, ...&#125;void * *</span></span><br><span class="line"><span class="string">[0]0x00007ff7c5c71569 &#123;OOPLearning.exe!A::AvFunc(void)&#125;void *</span></span><br><span class="line"><span class="string">[1]0x00007ff7c5c712da &#123;OOPLearning.exe!C::ABvFunc(void)&#125;void *</span></span><br><span class="line"><span class="string">+a0x000001c7ad0ebc30 &quot;A葺葳馫,&quot;char *</span></span><br><span class="line"><span class="string">//B</span></span><br><span class="line"><span class="string">-B&#123;number=0x000001c7ad0ebab0 &#123;2&#125; &#125;B</span></span><br><span class="line"><span class="string">-__vfptr0x00007ff7c5c7bd00 &#123;OOPLearning.exe!void(* C::`vftable&#x27;</span>[<span class="number">4</span>])()&#125; &#123;<span class="number">0x00007ff7c5c71555</span> &#123;OOPLearning.exe!B::<span class="built_in">BvFunc</span>(<span class="type">void</span>)&#125;, ...&#125;<span class="type">void</span> * *</span><br><span class="line">[<span class="number">0</span>]<span class="number">0x00007ff7c5c71555</span> &#123;OOPLearning.exe!B::<span class="built_in">BvFunc</span>(<span class="type">void</span>)&#125;<span class="type">void</span> *</span><br><span class="line">[<span class="number">1</span>]<span class="number">0x00007ff7c5c71550</span> &#123;OOPLearning.exe![thunk]:C::ABvFunc`adjustor&#123;<span class="number">16</span>&#125;<span class="string">&#x27; (void)&#125;void *</span></span><br><span class="line"><span class="string">[2]0x00007ff7c5c715be &#123;OOPLearning.exe![thunk]:C::`vector deleting destructor&#x27;</span>`adjustor&#123;<span class="number">16</span>&#125;<span class="string">&#x27; (unsigned int)&#125;void *</span></span><br><span class="line"><span class="string">+number0x000001c7ad0ebab0 &#123;2&#125;int *</span></span><br><span class="line"><span class="string">+__vfptr0x00007ff7c5c7c038 &#123;OOPLearning.exe!void(* C::`vftable&#x27;</span>[<span class="number">4</span>])()&#125; &#123;<span class="number">0x00007ff7c5c71569</span> &#123;OOPLearning.exe!A::<span class="built_in">AvFunc</span>(<span class="type">void</span>)&#125;, ...&#125;<span class="type">void</span> * *</span><br><span class="line">+a<span class="number">0x000001c7ad0ebc30</span> <span class="string">&quot;A葺葳馫,&quot;</span><span class="type">char</span> *</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c2</span></span><br><span class="line">-c2<span class="number">0x000001c7ad0f7c60</span> &#123;...&#125;C *</span><br><span class="line"><span class="comment">//A</span></span><br><span class="line">-A&#123;a=<span class="number">0x000001c7ad0ebbf0</span>  &lt;字符串中的字符无效。&gt; &#125;A</span><br><span class="line">-__vfptr<span class="number">0x00007ff7c5c7c038</span> &#123;OOPLearning.exe!<span class="built_in">void</span>(* C::`vftable<span class="string">&#x27;[4])()&#125; &#123;0x00007ff7c5c71569 &#123;OOPLearning.exe!A::AvFunc(void)&#125;, ...&#125;void * *</span></span><br><span class="line"><span class="string">[0]0x00007ff7c5c71569 &#123;OOPLearning.exe!A::AvFunc(void)&#125;void *</span></span><br><span class="line"><span class="string">[1]0x00007ff7c5c712da &#123;OOPLearning.exe!C::ABvFunc(void)&#125;void *</span></span><br><span class="line"><span class="string">+a0x000001c7ad0ebbf0  &lt;字符串中的字符无效。&gt;char *</span></span><br><span class="line"><span class="string">//B</span></span><br><span class="line"><span class="string">-B&#123;number=0x000001c7ad0ebff0 &#123;3&#125; &#125;B</span></span><br><span class="line"><span class="string">-__vfptr0x00007ff7c5c7bd00 &#123;OOPLearning.exe!void(* C::`vftable&#x27;</span>[<span class="number">4</span>])()&#125; &#123;<span class="number">0x00007ff7c5c71555</span> &#123;OOPLearning.exe!B::<span class="built_in">BvFunc</span>(<span class="type">void</span>)&#125;, ...&#125;<span class="type">void</span> * *</span><br><span class="line">[<span class="number">0</span>]<span class="number">0x00007ff7c5c71555</span> &#123;OOPLearning.exe!B::<span class="built_in">BvFunc</span>(<span class="type">void</span>)&#125;<span class="type">void</span> *</span><br><span class="line">[<span class="number">1</span>]<span class="number">0x00007ff7c5c71550</span> &#123;OOPLearning.exe![thunk]:C::ABvFunc`adjustor&#123;<span class="number">16</span>&#125;<span class="string">&#x27; (void)&#125;void *</span></span><br><span class="line"><span class="string">[2]0x00007ff7c5c715be &#123;OOPLearning.exe![thunk]:C::`vector deleting destructor&#x27;</span>`adjustor&#123;<span class="number">16</span>&#125;<span class="string">&#x27; (unsigned int)&#125;void *</span></span><br><span class="line"><span class="string">+number0x000001c7ad0ebff0 &#123;3&#125;int *</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1>继承</h1><h2 id="访问属性">访问属性</h2><h3 id="私有-private">私有 private</h3><p>仅能在类内访问，不可继承，子类不可访问。</p><h3 id="保护-protected">保护 protected</h3><p>仅能在类内访问，可继承，子类可访问。</p><h3 id="公有-public">公有 public</h3><p>可在类内或类外访问，可继承，子类可访问。</p><h2 id="继承方式">继承方式</h2><h3 id="私有继承-private">私有继承 private</h3><p>父类中的public、protected成员以private属性继承至子类中。（访问权限降为private）</p><h3 id="保护继承-protected">保护继承 protected</h3><p>父类中的public、protected成员以protected属性继承至子类中。（访问权限降为protected）</p><h3 id="公有继承-public">公有继承 public</h3><p>父类中的public、protected成员以原有属性继承至子类中。（保持原有访问权限）</p><h2 id="类型转换">类型转换</h2><p>一个公有派生类的对象在使用上可以被当作基类的对象，反之则不可。<br>具体表现在：</p><ul><li>派生类的对象可以隐含转换为基类对象。</li><li>派生类的对象可以初始化基类的引用。</li><li>派生类的指针可以隐含转换为基类的指针。</li></ul><p>通过基类对象名、指针只能使用从基类继承的成员，派生类新增的成员不能使用。</p><h2 id="构造函数与析构函数">构造函数与析构函数</h2><p><strong>构造函数</strong>在创建该类对象时调用。必须使用new、malloc等创建该类对象的指针或引用或传值传参传入参数时才会调用，直接构建对象不会调用。</p><p><strong>析构函数</strong>在删除该类对象时调用。必须使用delete、free删除该类对象的指针或引用或指针&amp;引用超出作用域时才会调用，</p><h1>多继承</h1><h2 id="构造顺序与析构顺序">构造顺序与析构顺序</h2><p>构造函数依照继承父类的顺序调用,最后构造子类。</p><p>析构函数依照继承父类的逆序调用，最先析构子类。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* a;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* number;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n):<span class="built_in">number</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))&#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> number;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>():<span class="built_in">A</span>(),<span class="built_in">B</span>(<span class="number">2</span>)&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* c2 = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    <span class="keyword">delete</span> c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Create A</span><br><span class="line">Create B</span><br><span class="line">Create C</span><br><span class="line">Destroy C</span><br><span class="line">Destroy B</span><br><span class="line">Destroy A</span><br></pre></td></tr></table></figure><h2 id="菱形继承与虚基类">菱形继承与虚基类</h2><h3 id="二义性">二义性</h3><p><strong>问题</strong>：当多继承的两个父类有相同名称的成员变量或函数时，会产生<strong>二义性</strong>问题。</p><p><strong>二义性</strong>就是编译器不知道程序员指出的变量具体是哪个类中的变量，于是编译器就会报错。</p><p>可以在变量前使用类限定符，标识清楚是哪个类中的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">number</span>(n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n):<span class="built_in">number</span>(n)&#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> n):<span class="built_in">A</span>(n*n),<span class="built_in">B</span>(n)&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* c = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;number in B = &quot; &lt;&lt; c-&gt;number &lt;&lt; endl; Error 错误： C::number不明确</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number in A = &quot;</span> &lt;&lt; c-&gt;A::number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number in B = &quot;</span> &lt;&lt; c-&gt;B::number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="菱形继承">菱形继承</h3><p>当子类继承了多个基类，而这些基类又继承自同一基类，就会造成子类中存在多个间接基类的成员。当访问该成员时会造成冗余，与数据不一致性。</p><p>添加一个A类和B类的共同基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> vInt;</span><br><span class="line">    <span class="built_in">VirtualClass</span>(<span class="type">int</span> n) : <span class="built_in">vInt</span>(n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Create VirtualClass&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">VirtualClass</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Delete VirtualClass&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> VirtualClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">number</span>(n),<span class="built_in">VirtualClass</span>(n<span class="number">+2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> VirtualClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n):<span class="built_in">number</span>(n), <span class="built_in">VirtualClass</span>(n + <span class="number">1</span>) &#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> n):<span class="built_in">A</span>(n*n),<span class="built_in">B</span>(n)&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* c = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;number in B = &quot; &lt;&lt; c-&gt;number &lt;&lt; endl; Error 错误： C::number不明确</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number in A = &quot;</span> &lt;&lt; c-&gt;A::number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number in B = &quot;</span> &lt;&lt; c-&gt;B::number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number in (A)BaseClass = &quot;</span> &lt;&lt; c-&gt;A::vInt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number in (B)BaseClass = &quot;</span> &lt;&lt; c-&gt;B::vInt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Create VirtualClass</span><br><span class="line">Create A</span><br><span class="line">Create VirtualClass</span><br><span class="line">Create B</span><br><span class="line">Create C</span><br><span class="line">number in A = <span class="number">16</span></span><br><span class="line">number in B = <span class="number">4</span></span><br><span class="line">number <span class="built_in">in</span> (A)BaseClass = <span class="number">18</span></span><br><span class="line">number <span class="built_in">in</span> (B)BaseClass = <span class="number">5</span></span><br><span class="line">Destroy C</span><br><span class="line">Destroy B</span><br><span class="line">Delete VirtualClass</span><br><span class="line">Destroy A</span><br><span class="line">Delete VirtualClass</span><br></pre></td></tr></table></figure><p>根据输出和调试结果可以得出以下结论：<br><strong>没有使用虚继承时，子类的内存中包含两个继承的基类，每个基类中又各有一份间接基类的对象数据</strong></p><p><img src="https://s2.loli.net/2024/07/31/bsZEXqJxR2HS9iA.png" alt="未使用虚继承时C类对象的内存示意图" title="未使用虚继承时C类对象的内存示意图"></p><p>下面使用虚继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualClass <span class="comment">//使用虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">number</span>(n),<span class="built_in">VirtualClass</span>(n<span class="number">+2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create A&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualClass <span class="comment">//使用虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n):<span class="built_in">number</span>(n), <span class="built_in">VirtualClass</span>(n + <span class="number">1</span>) &#123;cout&lt;&lt;<span class="string">&quot;Create B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> n):<span class="built_in">A</span>(n*n),<span class="built_in">B</span>(n),<span class="built_in">VirtualClass</span>(n*n+n<span class="number">+2</span>)&#123;cout&lt;&lt;<span class="string">&quot;Create C&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//添加VirtualClass的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用虚继承后，C的内部结构发生了变化。子类对象中包含了A、B、VirtualClass的对象数据，A、B两个类中创建了VirtualClass的指针，指向C中的VirtualClass。避免了数据的冗余，解决了不一致性。</p><p><img src="https://s2.loli.net/2024/07/31/lhNuBx2FmyPpGWV.jpg" alt="使用虚继承时C类对象的内存示意图" title="使用虚继承时C类对象的内存示意图"></p><h3 id="总结">总结</h3><ul><li><p><strong>虚基类解决的问题：</strong><br>当派生类从多个基类派生，而这些基类又有共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性。</p></li><li><p><strong>虚基类的作用：</strong><br>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题。<br>为最远的派生类提供唯一的基类成员，而不重复产生多次复制</p></li><li><p><strong>一些需注意的点：</strong><br>在第一级继承时就要将共同基类设计为虚基类。<br>虚基类的成员是由最远派生类（建立对象时所指定的类，示例中的C类）的构造函数通过调用虚基类的构造函数进行初始化的。</p></li></ul><h1>虚继承的底层原理</h1><p>是时候谈一谈虚继承的底层原理了。</p><p>上一小节中的示意图明显展示了A、B类中各有一个指向同一个虚基类的指针。</p><p>准确说，这个指针就是<strong>虚基表指针（vbptr）</strong>，指向的是虚基表。虚基表中的记录了到虚基类的内存偏移量，根据这一偏移量能够找到虚基类的指针，然后就可以访问数据了。</p><p>首先使用开发者命令查看C类的内部结构</p><figure class="highlight plaintext"><figcaption><span>Shell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1reportSingleClassLayoutC main.cpp</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位系统</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> C <span class="title">size</span><span class="params">(<span class="number">24</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | +--- (base class B)</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | | &#123;</span>vfptr&#125;</span><br><span class="line"> <span class="number">4</span>      | | &#123;vbptr&#125;</span><br><span class="line"> <span class="number">8</span>      | | number</span><br><span class="line">        | +---</span><br><span class="line"><span class="number">12</span>      | +--- (base <span class="keyword">class</span> A)</span><br><span class="line"><span class="number">12</span>      | | &#123;vbptr&#125;</span><br><span class="line"><span class="number">16</span>      | | number</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br><span class="line">        +--- (<span class="keyword">virtual</span> base VirtualClass)</span><br><span class="line"><span class="number">20</span>      | vInt</span><br><span class="line">        +---</span><br><span class="line"><span class="comment">// 虚函数表</span></span><br><span class="line">C::$vftable@:</span><br><span class="line">        | &amp;C_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;C::&#123;dtor&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A的虚基表，记录A类到虚基类地址的偏差值，这里是8（20-12 = 8）</span></span><br><span class="line">C::$vbtable@A@:</span><br><span class="line"> <span class="number">0</span>      | <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>      | <span class="number">8</span> (<span class="built_in">Cd</span>(A<span class="number">+0</span>)VirtualClass)</span><br><span class="line"><span class="comment">//B的虚基表，记录B类到虚基类地址的偏差值，这里是16（20-4 = 16）</span></span><br><span class="line">C::$vbtable@B@:</span><br><span class="line"> <span class="number">0</span>      | <span class="number">-4</span></span><br><span class="line"> <span class="number">1</span>      | <span class="number">16</span> (<span class="built_in">Cd</span>(B<span class="number">+4</span>)VirtualClass)</span><br></pre></td></tr></table></figure><p>接着，在VS中进行一次调试。找到C实例对象的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是C对象的存储地址</span></span><br><span class="line"><span class="number">0x008FFE44</span>  b8 ab e1 <span class="number">00</span>  ???.<span class="comment">//c地址</span></span><br><span class="line"><span class="number">0x008FFE48</span>  cc ab e1 <span class="number">00</span>  ???.<span class="comment">// c-&gt;B的虚基表指针</span></span><br><span class="line"><span class="number">0x008FFE4C</span>  <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....<span class="comment">// c-&gt;B::number</span></span><br><span class="line"><span class="number">0x008FFE50</span>  c0 ab e1 <span class="number">00</span>  ???.<span class="comment">// c-&gt;A的虚基表指针</span></span><br><span class="line"><span class="number">0x008FFE54</span>  <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....<span class="comment">// c-&gt;A::number</span></span><br><span class="line"><span class="number">0x008FFE58</span>  <span class="number">16</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....<span class="comment">//c-&gt;vInt地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A的虚基表指针指向的偏移量 16进制 转换为10进制为 8，与上面类内结构所示相同</span></span><br><span class="line"><span class="number">0x00E1ABC0</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........</span><br><span class="line"><span class="comment">// B的虚基表指针指向的偏移量 16进制 转换为10进制为 16，与上面的类内结构所示相同</span></span><br><span class="line"><span class="number">0x00E1ABCC</span>  fc ff ff ff <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ?.......</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：</p><ul><li>可以看到当我们使用虚继承时，虚继承父类的子类中会生成一个虚基表指针，指向虚基表。</li><li>我们可能使用父类（示例中的A类或B类）的引用指向子类（示例中的C类）。此时，访问间接父类的数据，就会通过父类中虚基表内存偏移量找到间接父类的指针，进一步访问其中的数据。</li></ul><p>据此，可以再优化一下上面的内存结构图：</p><p><img src="https://s2.loli.net/2024/07/31/Uwj5Fe3Ln2m4srf.png" alt="使用虚继承时C类对象的内存示意图" title="使用虚继承时C类对象的内存示意图"></p>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++封装</title>
      <link href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E5%B0%81%E8%A3%85/"/>
      <url>/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>类</h1><h1>类与结构体</h1><h1>访问限制符</h1>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象编程OOP</title>
      <link href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP/"/>
      <url>/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP/</url>
      
        <content type="html"><![CDATA[<h1>面向对象的三个特点</h1><p>面向对象编程将世间万物<strong>抽象</strong>出概念，具有<strong>封装、继承、多态</strong>的特点。</p><p>（其实个人感觉，面向对象与黑格尔的哲学思想很接近，不知道提出面向对象编程思想的老先生是不是收到了黑格尔的影响）</p><h2 id="抽象">抽象</h2><p>将一类对象的<strong>共同属性、行为、功能</strong>进行概括，总结成<strong>类</strong>。</p><h2 id="封装">封装</h2><p>将抽象的数据、代码进行打包管理，放置于类中，提供合理的访问接口。</p><h2 id="继承">继承</h2><p>在已有类的基础上进行对属性、行为、功能描述的拓展。<br><font size="4"><a href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E7%BB%A7%E6%89%BF/" title="C++继承">C++继承</a></font></p><h2 id="多态">多态</h2><p>名称相同但实现不同功能的方式。</p><p>分为<strong>静态多态</strong>和<strong>动态多态</strong>两种，静态多态通过<strong>重载函数和泛型编程</strong>实现，动态多态通过<strong>虚函数</strong>实现。</p><p><font size="4"><a href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E5%A4%9A%E6%80%81/" title="C++多态">C++多态</a></font></p>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity_DerekBehaviourTrees</title>
      <link href="/2024/07/27/Unity/DerekPlugins/Unity_DerekBehaviourTrees/"/>
      <url>/2024/07/27/Unity/DerekPlugins/Unity_DerekBehaviourTrees/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>**有限状态机（Finite State Mechine，FSM）<strong>与</strong>行为树（Behaviour Trees）**是常见的两种控制游戏角色行为逻辑的方式。</p><p>FSM将走、跑、跳、攻击、受击等状态不假区分的放到一起并进行逻辑连接，实践中需要我们维护一个当前状态，并时刻更新该状态的逻辑。对于简单的少数的状态，FSM是适用的。但如果状态间的切换逻辑复杂，FSM就会变为“蜘蛛网”，难以维护。</p><p>下面是我实现的FSM（<a href="%22%E6%B2%A1%E5%86%99%E5%8D%9A%E5%AE%A2%E5%91%A2%EF%BC%8C%E6%AD%A3%E5%9C%A8%E6%96%BD%E5%B7%A5%E4%B8%AD%E3%80%82%E3%80%82%E3%80%82%22">“没写博客呢，正在施工中。。。”</a>）；</p><p>对于复杂的行为，最好使用行为树。行为树正如其名，它会向层次遍历树一样从根节点开始依次判断每个节点是否符合要求，对于符合要求的节点，我们会执行这一节点下的行动节点。</p><p>下面参考文章：<a href="https://developer.unity.cn/projects/6569d98aedbc2a0a165f740e" title="游戏AI行为决策方法——行为树">“游戏AI行为决策方法——行为树”</a>，实现自己的行为树组件(没有全抄)。</p><h1>行为树（Behaviour Trees）</h1><p><img src="https://s2.loli.net/2024/07/31/zmXiDMhkvF5KcnJ.png" alt="行为树 BehaviourTrees" title="行为树 BehaviourTrees"><br>如上图所示，一棵行为树包含根节点、动作选择节点（组合节点）、动作节点、修饰节点这几部分。</p><h2 id="理解行为树">理解行为树</h2><h3 id="动作节点">动作节点</h3><p>动作节点记录简单的基础行为，支持自定义。</p><h3 id="修饰节点">修饰节点</h3><p>特殊的节点，只包含一个子节点。<br>有两种修饰节点：</p><h4 id="取反节点-Inverter">取反节点 Inverter</h4><h4 id="重复执行节点-Repeat">重复执行节点 Repeat</h4><h3 id="组合节点">组合节点</h3><p>常见的组合节点有<strong>选择节点</strong>、<strong>顺序节点</strong>。其余还有<strong>并行节点</strong>、<strong>过滤节点</strong>、<strong>主动选择节点</strong>、<strong>监视节点</strong>等。</p><h4 id="选择节点-Selector">选择节点 Selector</h4><p>按照从左至右的顺序，当一个动作执行完成时就会返回。</p><h4 id="顺序节点-Sequence">顺序节点 Sequence</h4><p>按照从左至右的顺序，依次执行每个动作，直到全部执行完成或某个动作执行中被打断。</p><h2 id="实现">实现</h2><h3 id="基类">基类</h3><h4 id="所有节点的基类">所有节点的基类</h4><p>所有节点均具有一个运行状态；需要进行逻辑更新；需要实现添加节点的功能。</p><h4 id="组合节点基类">组合节点基类</h4><h3 id="派生类">派生类</h3>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎客户端 </category>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> DerekPlugins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的智能指针</title>
      <link href="/2024/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2024/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>书接上文！<br><font size="4"><a href="/2024/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88/" title="C++中的指针">C++中的指针</a></font></p><p><strong>内存泄露</strong>问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Create MyObject Object&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Delete MyObject Object&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyObject* obj = <span class="keyword">new</span> <span class="built_in">MyObject</span>();</span><br><span class="line">    <span class="comment">//delete obj;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create MyObject Object</span><br></pre></td></tr></table></figure><h1>智能指针</h1><p>智能指针帮助我们<strong>自动释放不再使用的内存，从而避免内存泄漏问题</strong>。</p><ul><li>C++98中加入了auto_ptr</li><li>C++11中auto_ptr更新为unique_ptr,同时加入了shared_ptr、weak_ptr</li></ul><p>智能指针本质上是对指针的包装。在构造智能指针类时创建一个指针，重载*、-&gt;等运算符，在析构智能指针类时释放该指针的地址。<br>下面是智能指针的简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MySmartPtr</span>(T* p = <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MySmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Construct MyObject&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Delete MyObject&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MySmartPtr&lt;MyObject&gt; <span class="title">obj</span><span class="params">(<span class="keyword">new</span> MyObject())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="智能指针的声明">智能指针的声明</h2><p>各种智能指针都是一个模板类。可以使用如下方法创建(以auto_ptr为例)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;Class&gt; <span class="title">valueName</span><span class="params">(<span class="keyword">new</span> Class())</span></span>;</span><br><span class="line">auto_ptr&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">valueName</span>(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">valueName</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="auto-ptr">auto_ptr</h2><p>C++98的智能指针，已被unique_ptr替换掉，基本不用，就不介绍了。<br>有兴趣可以翻看这些资料：<br><a href="https://blog.csdn.net/czc1997/article/details/84026887" title="C++智能指针：auto_ptr详解">C++智能指针：auto_ptr详解</a><br><a href="https://en.cppreference.com/w/cpp/memory/auto_ptr" title="std::auto_ptr CPP Reference">std::auto_ptr CPP Reference</a></p><h2 id="unique-ptr">unique_ptr</h2><p>auto_ptr的进阶版。<br>unique_ptr不共享指针，只能指向一个对象。无法复制到其他unique_ptr，无法进行值传递，也无法使用需要副本的任何STL算法。<br>unique_ptr的指针变动只能通过移动unique_ptr实现所有权的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Construct MyObject&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyObject</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        num = n;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Construct MyObject, n=&quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DebugInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;DebugInfo: num = &quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Delete MyObject, n=&quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UniquePtrAdd</span><span class="params">(unique_ptr&lt;MyObject&gt; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;num += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UniquePtrAddReference</span><span class="params">(unique_ptr&lt;MyObject&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;num += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;MyObject&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;MyObject&gt;();</span><br><span class="line">    unique_ptr&lt;MyObject&gt; ptr2 = std::<span class="built_in">make_unique</span>&lt;MyObject&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//unique_ptr&lt;MyObject&gt; ptr3 = ptr1; ——Error</span></span><br><span class="line">    <span class="comment">//unique_ptr&lt;MyObject&gt; ptr3(ptr2); ——Error</span></span><br><span class="line">    <span class="comment">//UniquePtrAdd(ptr2); ——Error</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">DebugInfo</span>();</span><br><span class="line">    <span class="built_in">UniquePtrAddReference</span>(ptr2);</span><br><span class="line">    ptr2-&gt;<span class="built_in">DebugInfo</span>();</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ptr1: &quot;</span>&lt;&lt;ptr1&lt;&lt;endl;</span><br><span class="line">    unique_ptr&lt;MyObject&gt; ptr3 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ptr1: &quot;</span>&lt;&lt;ptr1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ptr3: &quot;</span>&lt;&lt;ptr3&lt;&lt;endl;</span><br><span class="line">    ptr3-&gt;<span class="built_in">DebugInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Construct MyObject</span><br><span class="line">Construct MyObject, n=<span class="number">4</span></span><br><span class="line">DebugInfo: num = <span class="number">4</span></span><br><span class="line">DebugInfo: num = <span class="number">6</span></span><br><span class="line">ptr1: <span class="number">0000023</span>8CFBF7A10</span><br><span class="line">ptr1: <span class="number">0000000000000000</span></span><br><span class="line">ptr3: <span class="number">0000023</span>8CFBF7A10</span><br><span class="line">DebugInfo: num = <span class="number">0</span></span><br><span class="line">Delete MyObject, n=<span class="number">0</span></span><br><span class="line">Delete MyObject, n=<span class="number">6</span></span><br></pre></td></tr></table></figure><p>可以看到，经过转移的指针已经变为空指针，而转移目标获取了被转移指针指向的地址。</p><h2 id="shared-ptr">shared_ptr</h2><p>多个指针共享一个对象。通过引用计数器检测指针使用状态。当没有指针指向该对象时该对象会自动销毁。<br>需要注意的是，**对于共享指针来说，传值传参和引用传参均可以改变对象的成员。**因为传值传参调用复制构造函数后用声明了一个指针，使用该指针进行的操作均会作用于所有指针指向的共同对象上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SharedPtrAdd</span><span class="params">(shared_ptr&lt;MyObject&gt; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;num += <span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;SharedPtr Count:&quot;</span>&lt;&lt;obj.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SharedPtrAddReference</span><span class="params">(shared_ptr&lt;MyObject&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;num += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;MyObject&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;MyObject&gt;(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;SharedPtr 1 Count:&quot;</span>&lt;&lt;ptr<span class="number">1.</span><span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    shared_ptr&lt;MyObject&gt; ptr2 = ptr1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;SharedPtr 1 Count:&quot;</span>&lt;&lt;ptr<span class="number">1.</span><span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    shared_ptr&lt;MyObject&gt; ptr3 = ptr2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;SharedPtr 3 Count:&quot;</span>&lt;&lt;ptr<span class="number">3.</span><span class="built_in">use_count</span>()&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Before Move All Pointer&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ptr1 = std::<span class="built_in">make_shared</span>&lt;MyObject&gt;(<span class="number">0</span>);</span><br><span class="line">    ptr2 = ptr1;</span><br><span class="line">    ptr3 = ptr1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After Move All Pointer&quot;</span>&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharedPtrAdd</span>(ptr2); <span class="comment">//—— shared_ptr在传值传参时需要注意对复制的指针进行操作，会影响到输入值。</span></span><br><span class="line">    <span class="built_in">SharedPtrAddReference</span>(ptr1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;SharedPtr Count:&quot;</span>&lt;&lt;ptr<span class="number">3.</span><span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    ptr3-&gt;<span class="built_in">DebugInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Construct MyObject, n=<span class="number">4</span></span><br><span class="line">SharedPtr <span class="number">1</span> Count:<span class="number">1</span></span><br><span class="line">SharedPtr <span class="number">1</span> Count:<span class="number">2</span></span><br><span class="line">SharedPtr <span class="number">3</span> Count:<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Before Move All Pointer</span><br><span class="line">Construct MyObject, n=<span class="number">0</span></span><br><span class="line">Delete MyObject, n=<span class="number">4</span></span><br><span class="line">After Move All Pointer</span><br><span class="line"></span><br><span class="line">SharedPtr Count:<span class="number">4</span></span><br><span class="line">SharedPtr Count:<span class="number">3</span></span><br><span class="line">DebugInfo: num = <span class="number">5</span></span><br><span class="line">Delete MyObject, n=<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="weak-ptr">weak_ptr</h2><p>weak_ptr用于辅助shared_ptr工作，不具有普通指针的功能。没有重载*和-&gt;。<br>weak_ptr只能从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr不共享资源，它的构造不会引起指针引用计数的增加。<br>weak_ptr可以用于避免循环引用带来的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Course.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Course* c = <span class="keyword">new</span> <span class="built_in">Course</span>();</span><br><span class="line">    <span class="function">shared_ptr&lt;Student&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Student())</span></span>;</span><br><span class="line">    <span class="comment">//weak_ptr&lt;Student&gt; p2(new Student()); ——Error</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p1 Count:&quot;</span>&lt;&lt;p<span class="number">1.</span><span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="function">weak_ptr&lt;Student&gt; <span class="title">p_weak</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p1 Count:&quot;</span>&lt;&lt;p<span class="number">1.</span><span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p_weak Count:&quot;</span>&lt;&lt;p_weak.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="function">shared_ptr&lt;Student&gt; <span class="title">p3</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p_weak Count:&quot;</span>&lt;&lt;p_weak.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p1 Course:&quot;</span>&lt;&lt;p1-&gt;course&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(!p_weak.<span class="built_in">expired</span>()) <span class="comment">//expired() &lt;==&gt; (use_count() == 0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;Student&gt; p4= p_weak.<span class="built_in">lock</span>(); <span class="comment">//从弱指针获取共享指针的副本</span></span><br><span class="line">        </span><br><span class="line">        p4-&gt;<span class="built_in">SetCourse</span>(c);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1 Course:&quot;</span>&lt;&lt;p1-&gt;course&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Student&gt; p4 = <span class="built_in">make_shared</span>&lt;Student&gt;();</span><br><span class="line">    p3 = p4;</span><br><span class="line">    p1 = p4;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p_weak Count:&quot;</span>&lt;&lt;p_weak.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Create Course</span><br><span class="line">Create Student</span><br><span class="line">p1 Count:<span class="number">1</span></span><br><span class="line">p1 Count:<span class="number">1</span></span><br><span class="line">p_weak Count:<span class="number">1</span></span><br><span class="line">p_weak Count:<span class="number">2</span></span><br><span class="line">p1 Course:<span class="number">0000000000000000</span></span><br><span class="line">p1 Course:<span class="number">000001</span>DF98BCAB10</span><br><span class="line">Create Student</span><br><span class="line">Delete Student</span><br><span class="line">p_weak Count:<span class="number">0</span> <span class="comment">//弱指针在技术为0时不会自动销毁，通过lock()获取的共享指针副本为空</span></span><br><span class="line">Delete Student</span><br></pre></td></tr></table></figure><h3 id="循环引用">循环引用</h3><p>当两个类分别有对方类型的一个实例，在释放指针时，就会出现释放一个指针而另一指针的为空的情况。</p><ul><li>使用普通指针的错误写法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Course.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student* student;</span><br><span class="line">    <span class="built_in">Course</span>();</span><br><span class="line">    ~<span class="built_in">Course</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStudent</span><span class="params">(Student*&amp; s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in Student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Course.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Course* course;</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCourse</span><span class="params">(Course*&amp; c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Course.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Course* c = <span class="keyword">new</span> <span class="built_in">Course</span>();</span><br><span class="line">    Student* s = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line"></span><br><span class="line">    c-&gt;<span class="built_in">SetStudent</span>(s);</span><br><span class="line">    s-&gt;<span class="built_in">SetCourse</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Student Has Course: &quot;</span>&lt;&lt;s-&gt;course-&gt;student&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Create Course</span><br><span class="line">Create Student</span><br><span class="line">Delete Course</span><br><span class="line">Student Has Course: DDDDDDDDDDDDDDDD</span><br></pre></td></tr></table></figure><p>可以看到退出时学生对象中的课程指针已经被释放掉了。如果实际应用中试图在删除某一对象后通过另一对象进行访问就会发生错误。</p><ul><li>使用shared_ptr的错误用法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Student&gt; student;  <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">Course</span>();</span><br><span class="line">    ~<span class="built_in">Course</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStudent</span><span class="params">(std::shared_ptr&lt;Student&gt;&amp; s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in Student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Course.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Course&gt; course;  <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCourse</span><span class="params">(std::shared_ptr&lt;Course&gt;&amp; c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Course.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Course&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Course())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;Student&gt; <span class="title">s</span><span class="params">(<span class="keyword">new</span> Student())</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Course Ptr:&quot;</span>&lt;&lt;c.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Student Ptr:&quot;</span>&lt;&lt;s.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    c-&gt;<span class="built_in">SetStudent</span>(s);</span><br><span class="line">    s-&gt;<span class="built_in">SetCourse</span>(c);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Course Ptr:&quot;</span>&lt;&lt;c.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Student Ptr:&quot;</span>&lt;&lt;s.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Create Course</span><br><span class="line">Create Student</span><br><span class="line">Course Ptr:<span class="number">1</span></span><br><span class="line">Student Ptr:<span class="number">1</span></span><br><span class="line">Course Ptr:<span class="number">2</span></span><br><span class="line">Student Ptr:<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>使用weak_ptr的正确用法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in Course.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;Student&gt; student;  <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">Course</span>();</span><br><span class="line">    ~<span class="built_in">Course</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStudent</span><span class="params">(std::shared_ptr&lt;Student&gt;&amp; s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in Student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Course.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Course&gt; course;  <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCourse</span><span class="params">(std::shared_ptr&lt;Course&gt;&amp; c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Course.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Course&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Course())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;Student&gt; <span class="title">s</span><span class="params">(<span class="keyword">new</span> Student())</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Course Ptr:&quot;</span>&lt;&lt;c.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Student Ptr:&quot;</span>&lt;&lt;s.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    c-&gt;<span class="built_in">SetStudent</span>(s);</span><br><span class="line">    s-&gt;<span class="built_in">SetCourse</span>(c);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Course Ptr:&quot;</span>&lt;&lt;c.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Student Ptr:&quot;</span>&lt;&lt;s.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Create Course</span><br><span class="line">Create Student</span><br><span class="line">Course Ptr:<span class="number">1</span></span><br><span class="line">Student Ptr:<span class="number">1</span></span><br><span class="line">Course Ptr:<span class="number">2</span></span><br><span class="line">Student Ptr:<span class="number">1</span></span><br><span class="line">Delete Student</span><br><span class="line">Delete Course</span><br></pre></td></tr></table></figure><h1>参考资料</h1><ul><li><a href="https://www.cnblogs.com/wxquare/p/4759020.html" title="C++11中智能指针的原理、使用、实现">C++11中智能指针的原理、使用、实现</a></li><li><a href="https://geek-docs.com/cpp/cpp-tutorial/smart-pointer.html" title="C++ 智能指针">C++ 智能指针</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170" title="智能指针（现代 C++）">智能指针（现代 C++）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> 指针及智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL常用算法</title>
      <link href="/2024/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2024/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的指针</title>
      <link href="/2024/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88/"/>
      <url>/2024/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1>什么是指针</h1><p>指针表示存储某一对象（通常是变量、函数等）的内存地址。</p><h1>普通指针</h1><h2 id="指针与变量">指针与变量</h2><p>符号&amp;表示引用，变量名左侧的&amp;表示取该变量的地址。<br>符号<em>表示解引用，变量名左侧的</em>表示取该变量的值。<br>声明一个变量<strong>在类型名右侧用*表示声明该类型的指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;---------指针---------&quot;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> *pc, c;</span><br><span class="line">    </span><br><span class="line">    c = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address of c (&amp;c): &quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of c (c): &quot;</span> &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pc = &amp;c;    <span class="comment">// 指针pc保存变量c的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pc持有的指针地址(pc): &quot;</span>&lt;&lt; pc &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;地址指针pc持有的值(*pc): &quot;</span> &lt;&lt; *pc &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    c = <span class="number">11</span>;    <span class="comment">// 内存地址＆c中的值从5更改为11。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;地址指针pc持有(pc): &quot;</span> &lt;&lt; pc &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;地址指针pc持有的内容(*pc): &quot;</span> &lt;&lt; *pc &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    *pc = <span class="number">2</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address of c (&amp;c): &quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of c (c): &quot;</span> &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------指针---------</span><br><span class="line"><span class="function">Address of <span class="title">c</span> <span class="params">(&amp;c)</span>: <span class="number">000000</span>D3BDB3F604</span></span><br><span class="line"><span class="function">Value of c (c): <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">pc持有的指针地址(pc): <span class="number">000000</span>D3BDB3F604</span></span><br><span class="line"><span class="function">地址指针pc持有的值(*pc): <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">地址指针pc持有(pc): <span class="number">000000</span>D3BDB3F604</span></span><br><span class="line"><span class="function">地址指针pc持有的值(*pc): <span class="number">11</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Address of c (&amp;c): <span class="number">000000</span>D3BDB3F604</span></span><br><span class="line"><span class="function">Value of c (c): <span class="number">2</span></span></span><br></pre></td></tr></table></figure><h2 id="指针与数组">指针与数组</h2><h3 id="数组中元素的访问">数组中元素的访问</h3><h4 id="一维数组">一维数组</h4><p>数组的变量名本质是数组第一个元素的指针。除了可以通过[]访问数组元素，还可以使用指针的位移访问元素。<br>**PS.**C++中数组访问超出范围后仍然可以访问，但只是返回一个未初始化的值和一个连续的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a[0] value: &quot;</span>&lt;&lt; a[<span class="number">0</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*a value: &quot;</span>&lt;&lt; *a &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a address: &quot;</span>&lt;&lt; a &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a address: &quot;</span>&lt;&lt; &amp;a &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[0] address: &quot;</span>&lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a[3] value: &quot;</span>&lt;&lt; a[<span class="number">3</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a+3 address: &quot;</span>&lt;&lt; (a<span class="number">+3</span>) &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[3] address: &quot;</span>&lt;&lt; &amp;a[<span class="number">3</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[5] address: &quot;</span>&lt;&lt; &amp;a[<span class="number">5</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a[5] value: &quot;</span>&lt;&lt; a[<span class="number">5</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[6] address: &quot;</span>&lt;&lt; &amp;a[<span class="number">6</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a[6] value: &quot;</span>&lt;&lt; a[<span class="number">6</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] value: <span class="number">0</span></span><br><span class="line">*a value: <span class="number">0</span></span><br><span class="line">a address: <span class="number">000000E1082F</span>FB78</span><br><span class="line">&amp;a address: <span class="number">000000E1082F</span>FB78</span><br><span class="line">&amp;a[<span class="number">0</span>] address: <span class="number">000000E1082F</span>FB78</span><br><span class="line"></span><br><span class="line">a[<span class="number">3</span>] value: <span class="number">3</span></span><br><span class="line">a<span class="number">+3</span> address: <span class="number">000000E1082F</span>FB84</span><br><span class="line">&amp;a[<span class="number">5</span>] address: <span class="number">000000E1082F</span>FB8C</span><br><span class="line">a[<span class="number">5</span>] value: <span class="number">5</span></span><br><span class="line">&amp;a[<span class="number">6</span>] address: <span class="number">000000E1082F</span>FB90</span><br><span class="line">a[<span class="number">6</span>] value: <span class="number">-858993460</span></span><br></pre></td></tr></table></figure><h4 id="多维数组">多维数组</h4><p>下面示例均以二维数组为例。</p><ul><li>数组名指向多维数组第一个子数组的首位元素的地址。</li><li>多为数组的声明不能省略最后一个维度的数量。省略其他维度时编译器会推断总共需要申请多少内存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//——合法的</span></span><br><span class="line"><span class="type">int</span> b[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;     <span class="comment">//——合法的</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">2</span>][] = &#123;&#123;<span class="number">0</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;     <span class="comment">//——非法的</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a[1][2] value: &quot;</span>&lt;&lt;a[<span class="number">1</span>][<span class="number">2</span>]&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*(*(a+1)+2) value: &quot;</span>&lt;&lt;*(*(a<span class="number">+1</span>)<span class="number">+2</span>)&lt;&lt; <span class="string">&#x27;\n&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a address: &quot;</span>&lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[0] address: &quot;</span>&lt;&lt; &amp;a[<span class="number">0</span>]&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[0][0] address: &quot;</span>&lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] value: <span class="number">6</span></span><br><span class="line">*(*(a<span class="number">+1</span>)<span class="number">+2</span>) value: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">a address: <span class="number">000000</span>9C1993F528</span><br><span class="line">&amp;a[<span class="number">0</span>] address: <span class="number">000000</span>9C1993F528</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>] address: <span class="number">000000</span>9C1993F528</span><br></pre></td></tr></table></figure><h3 id="数组与函数">数组与函数</h3><p>下面是一段错误代码，结果并不符合预期</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">matrix_multiple</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>], <span class="type">int</span> b[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res[<span class="number">3</span>];</span><br><span class="line">    res[<span class="number">0</span>] = a[<span class="number">0</span>]*b[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">1</span>] = a[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">2</span>] = a[<span class="number">2</span>]*b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* mul = <span class="built_in">matrix_multiple</span>(a,b);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Result:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;mul[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result:-858993460,-858993460,-858993460,</span><br></pre></td></tr></table></figure><p>这是因为res变量的作用域仅在函数中，执行完函数后res会被销毁，再次访问属于危险操作。</p><p>一般可以这样修改：</p><ul><li>将res声明为静态变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">matrix_multiple</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>], <span class="type">int</span> b[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> res[<span class="number">3</span>];</span><br><span class="line">    res[<span class="number">0</span>] = a[<span class="number">0</span>]*b[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">1</span>] = a[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">2</span>] = a[<span class="number">2</span>]*b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result:<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,</span><br></pre></td></tr></table></figure><ul><li>使用动态数组声明res<br>别忘记手动删除new创建的指针。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">matrix_multiple</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>], <span class="type">int</span> b[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    res[<span class="number">0</span>] = a[<span class="number">0</span>]*b[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">1</span>] = a[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">2</span>] = a[<span class="number">2</span>]*b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* mul = <span class="built_in">matrix_multiple</span>(a,b);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Result:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;mul[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] mul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result:<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,</span><br></pre></td></tr></table></figure><ul><li>使用引用传参</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrix_multiple</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>], <span class="type">int</span> b[<span class="number">3</span>],<span class="type">int</span>*&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res[<span class="number">0</span>] = a[<span class="number">0</span>]*b[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">1</span>] = a[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">2</span>] = a[<span class="number">2</span>]*b[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">matrix_multiple</span>(a,b,res);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Result:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result:<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,</span><br></pre></td></tr></table></figure><h2 id="指针与函数">指针与函数</h2><h3 id="传值传参、地址传参与引用传参">传值传参、地址传参与引用传参</h3><ul><li><strong>传值传参</strong></li></ul><p>在向函数传递参数时，通常是<strong>传值传参</strong>。程序会默认复制一份变量，将复制好的变量传入函数中。因此如果函数中对输入做出了修改，输入的变量并不会发生改变。</p><ul><li><strong>地址传参</strong></li></ul><p><strong>地址传参</strong>也是传值传参。下面的例子可以看到地址传参传入的地址其实也是复制的，不会和输入产生联系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_address</span><span class="params">(<span class="type">int</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    ptr = &amp;a;</span><br><span class="line">    cout&lt;&lt;ptr&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;&amp;a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">print_address</span>(&amp;a);</span><br><span class="line">    cout&lt;&lt;&amp;a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000E2</span>D88FFD14</span><br><span class="line"><span class="number">000000E2</span>D88FFBF4</span><br><span class="line"><span class="number">000000E2</span>D88FFD14</span><br></pre></td></tr></table></figure><p>对传值传参来说，一方面，如果传入的变量类型占用内存较大，可能存在调用复制构造函数用时长，造成的程序效率下降的结果。另一方面，有时我们希望函数对输入的变量进行修改比如swap交换两个变量的值。所以需要用到<strong>引用传参</strong>。</p><ul><li><strong>引用传参</strong></li></ul><p>函数输入的参数如果在类型右侧加上&amp;，表示引用传值，不会调用复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">10</span>b:<span class="number">40</span></span><br><span class="line">a:<span class="number">40</span>b:<span class="number">10</span></span><br></pre></td></tr></table></figure><p>有时会配合const使用，以避免调用构造函数浪费时间，从而加快运行速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInCircle</span><span class="params">(<span class="type">const</span> Ray&amp; ray, <span class="type">const</span> <span class="type">float</span>&amp; t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Vector3 p = ray.origin + ray.direction * t;</span><br><span class="line">    Vector3 offset = diskCenter - p;</span><br><span class="line">    offset.y = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">magnitude</span>(offset);</span><br><span class="line">    <span class="keyword">return</span> (d&lt;= radius_pow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>地址传参与引用传参的区别</strong><br>地址传参使用指针传递参数，传入的参数是本质是<strong>变量</strong>、是<strong>可变的</strong>、<strong>与输入变量没有关联的</strong>、<strong>可空</strong>且<strong>无类型检查的</strong>。<br>引用传参是传递<strong>输入变量的别名</strong>，是<strong>不变的</strong>、<strong>始终与输入变量有关联</strong>、<strong>非空</strong>且<strong>有类型检查的</strong>。</li></ul><h3 id="函数指针">函数指针</h3><p>指针还可以指向函数，调用时使用指向函数的指针即可。</p><p>需要区别的是<strong>函数指针</strong>和<strong>指针函数</strong>，前者是指向函数的指针，后者是返回指针的函数。</p><p>函数指针声明格式如下：<strong>函数返回值类型 （&lt;*&gt;+&lt;变量名&gt;）(参数列表);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Call My Function1&quot;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string_2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Call My Function2: &quot;</span>&lt;&lt;a&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*func_ptr1)() = print_my_string_1;</span><br><span class="line">    <span class="built_in">func_ptr1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*func_ptr2)(<span class="type">int</span>) = print_my_string_2;</span><br><span class="line">    <span class="built_in">func_ptr2</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*func_ptr3)(<span class="type">int</span>,<span class="type">int</span>) = add;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">func_ptr3</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Call Add Function: &quot;</span>&lt;&lt;c&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Call My Function1</span><br><span class="line">Call My Function2: <span class="number">4</span></span><br><span class="line">Call Add Function: <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="回调函数">回调函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">void</span> (*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Call Func1&quot;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Call Func2&quot;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span>(*callBackTest)() = func2;</span><br><span class="line">    <span class="built_in">func1</span>(callBackTest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Call Func1</span><br><span class="line">Call Func2</span><br></pre></td></tr></table></figure><h2 id="内存管理（动态数组）">内存管理（动态数组）</h2><h3 id="一维数组-2">一维数组</h3><p>声明一个数组中存储类型的指针，使用new关键字声明一个该类型的数组，使指针指向该数组的头部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array_length = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;array_length;</span><br><span class="line">    <span class="type">int</span>* array_head = <span class="keyword">new</span> <span class="type">int</span>[array_length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array_length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;*(array_head+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array_length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Array &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;*(array_head+i)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Array <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">Array <span class="number">1</span> : <span class="number">2</span></span><br><span class="line">Array <span class="number">2</span> : <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="多维数组-2">多维数组</h3><p>声明一个数组中存储类型的指针，使用new关键字声明一个该类型的数组，使指针指向该数组的头部。高维数组可类推。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array_const[<span class="number">2</span>][<span class="number">3</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#125;; </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> array_x = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> array_y = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//--------这里为数组的声明</span></span><br><span class="line">    <span class="type">int</span>** array = <span class="keyword">new</span> <span class="type">int</span>*[array_x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array_x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array[i] = <span class="keyword">new</span> <span class="type">int</span>[array_y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--------这里为数组的声明</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;array_x;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>;y&lt;array_y;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;array[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;array_x;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>;y&lt;array_y;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;array[x][y]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>智能指针</h1><p>上面的例子中，使用new创建一个指针，使用delete删除该指针。这些操作都需要程序员手动操作，如果程序员忘记删除，就会造成<strong>内存泄露</strong>。所以C++设计了智能指针，在适当时刻自动删除指针。</p><p>篇幅有点长了，具体的内容见另一篇吧！<br><font size="4"><a href="/2024/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="C++中的智能指针">C++中的智能指针</a></font></p>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> 指针及智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL的优缺点以及应用场景</title>
      <link href="/2024/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++STL%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2024/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++STL%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1>STL的六种基本组件</h1><p>STL（Standard Template Library）是支持C++泛型的标准模板库，为用户提供了一些常用的数据结构及算法，包括链表、队列、集合等。STL包括<strong>六种</strong>基本组件：<strong>容器、迭代器、仿函数（也称 函数对象）、算法、适配器以及分配器</strong>。</p><p>个人理解上不妨把STL的种种概念看成将一堆文件放到一个抽屉柜中。抽屉柜（容器）有着各种款式，每种款式的抽屉格（迭代器）的排列顺序、大小都不一样（向量、链表、映射、集合等）。我们需要将一堆文件（程序运行中需要处理的数据），放入到抽屉格（迭代器）中。同时为了让文件更加有序，我们还需要对不同抽屉格中的文件的一些信息进行比较，然后按要求排列好顺序（算法）。</p><h2 id="容器-Container">容器 Container</h2><p>容器提供了各种数据结构，决定了数据之间的存储关系。容器分为序列容器（Sequence Container）和关联容器（Associative Container）两类，序列容器包含向量（vector）、链表(list)、数组（array）、队列(queue)、栈(stack)等，关联容器主要包含集合(set)、映射(map)等。使用容器可以帮助更好地标准化管理组织抽象的数据。</p><h3 id="序列容器（Sequence-Container）">序列容器（Sequence Container）</h3><ul><li>通过元素在容器中的位置顺序进行查找</li><li>序列容器在内存中是连续的</li><li>遵循一定顺序的元素通常使用序列容器</li></ul><h3 id="关联容器（Associative-Container）">关联容器（Associative Container）</h3><ul><li>通过键存储、读取元素</li><li>元素没有强制的序列顺序</li><li>更容易查找</li><li>一般使用树结构进行存储，常用于映射和集合关系</li></ul><h2 id="迭代器-Iterator">迭代器 Iterator</h2><p>迭代器可以看作一个泛化的指针，指向泛型数据。不同种类的迭代器就是指重载了哪些运算符（加减、前缀递增递减/后缀递增递减、等于等等）。以vector的迭代器为例，其重载了 +、-、++/–（前缀递增递减及后缀递增递减）、*、-&gt;、+=、-=、[]等运算符，是一个随机访问迭代器。如果说容器是不同形式的抽屉柜，那么迭代器就是一个抽屉，用户可以在抽屉里放入任何同种类型的数据。</p><p>迭代器提供了<strong>通用的访问容器中数据的途径</strong>，其作用是用来<strong>遍历容器</strong>。因为泛型算法是针对多种容器实现的通用算法，所以需要一种统一的方式遍历访问容器元素，迭代器的作用就作为连接容器和算法的桥梁起到<strong>为算法提供访问数据接口</strong>的作用。</p><p>迭代器共有五种，分别是输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器，分别实现了不同运算符的重载。<br><strong>（注：输入、输出不是相对于迭代器而言的，是相对于使用者而言的。就是说输入迭代器是只读的，输出迭代器是只写的）</strong></p><h3 id="输入迭代器">输入迭代器</h3><p>输入迭代器支持读取迭代器内容。（可以记为从迭代器获取输入）</p><h3 id="输出迭代器">输出迭代器</h3><p>输出迭代器支持向迭代器中写入内容。（可以记为向迭代器输出）</p><h3 id="前向迭代器">前向迭代器</h3><p>前向迭代器是功能最少的迭代器种类，一般包含输入、输出迭代器，即前向迭代器一般支持读写。<br>此外支持++向前推进迭代器，以及!=、==两个运算符。</p><h3 id="双向迭代器">双向迭代器</h3><p>双向迭代器在前向迭代器的基础上添加了向后推进迭代器的功能，即重载了–运算符。</p><h3 id="随机访问迭代器">随机访问迭代器</h3><p>随机访问迭代器在双向迭代器的基础上重载了[]、+=、-=等运算符，以支持任意访问迭代器内容。</p><p><img src="https://s2.loli.net/2024/07/21/p4fU2vc3nPrILRb.png" alt="迭代器种类关系示意图" title="迭代器种类关系示意图"></p><p><img src="https://s2.loli.net/2024/07/24/tDnp4CqcuX7hMH8.png" alt="不同容器的迭代器种类" title="不同容器的迭代器种类"><br><strong>注：这里的stack和queue没有迭代器是因为两个容器都是deque的适配器。</strong></p><h2 id="仿函数（函数对象-Function-Object）">仿函数（函数对象 Function Object）</h2><p>函数对象指<strong>重载了函数调用操作符（函数调用操作符为“（）”）<strong>的</strong>类</strong>。称该行为称为<strong>函数对象</strong>或<strong>仿函数</strong>。</p><p>函数对象的本质是一个<strong>类</strong>，而非函数。</p><p>常与算法部分结合使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostram&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="title">MyaPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector v1 = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    for_each(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),<span class="built_in">Myprint</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法-Algorithm">算法 Algorithm</h2><p>C++提供的内置通用算法，可以用于不同容器。大部分算法集中在<algorithm>头文件中。其他算法在<functional>、<numeric>中。</numeric></functional></algorithm></p><p>不同容器的常见STL算法请见这篇文章：<br><font size="4"><a href="/2024/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" title="C++STL常用算法">C++ STL常用算法</a></font></p><h2 id="适配器-Adaptor">适配器 Adaptor</h2><p>适配器将一个类的接口转化为另一个类的接口。STL中的适配器将不同的容器、迭代器和函数对象进行二次封装以实现对旧组件的利用。<br>适配器分为容器适配器、迭代适配器、函数适配器三种。具体内容可见下面这篇博客:<br><a href="https://blog.csdn.net/yueguangmuyu/article/details/114359975" title="STL适配器详解">STL适配器详解</a></p><h2 id="分配器-Allocator">分配器 Allocator</h2><p>由于使用new关键字创建指针的底层是调用malloc函数，而malloc函数常常会申请多余的空间，造成内存的浪费。为了高效的运行，需要对申请空间的过程进行修改，同时也需要让算法识别迭代器类型以达到高效的运行效率。<br>具体的分配器内容可见下面这篇博客：<br><a href="https://blog.csdn.net/zj1131190425/article/details/99299714" title="C++STL学习笔记(4) 分配器(Allocator)">C++STL学习笔记(4) 分配器(Allocator)</a></p><h1>常用容器及其优缺点</h1><h2 id="向量-vector">向量 vector</h2><p>vector是基于 <strong>倍增</strong> 思想的<strong>内存连续</strong>的顺序容器，可以实现高效的<strong>随机存取</strong>、尾部加入或删除新元素等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;v<span class="number">2.</span><span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;&amp;(v2[i])&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000001E512AAE500 000001E512AAE504 000001E512AAE508 000001E512AAE50C</span><br></pre></td></tr></table></figure><p>在元素个数超出容量时，vector将自动分配更多的空间，这一分配过程将当前vector的容量翻倍分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//vector的创建</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1;<span class="comment">//空的vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">3</span>,<span class="number">10</span>)</span></span>;<span class="comment">//创建含有3个10的vector</span></span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;--------vector容量的重新分配--------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v3 original address:&quot;</span>&lt;&lt; &amp;v3 &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v3 element address:&quot;</span>&lt;&lt; &amp;(v3[<span class="number">2</span>]) &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v3 original size:&quot;</span>&lt;&lt; v<span class="number">3.</span><span class="built_in">size</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v3 original capacity:&quot;</span>&lt;&lt; v<span class="number">3.</span><span class="built_in">capacity</span>() &lt;&lt;std::endl;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;after reserve v3, it&#x27;s address:&quot;</span>&lt;&lt; &amp;v3 &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;after reserve v3, v3 element address:&quot;</span>&lt;&lt; &amp;(v3[<span class="number">2</span>]) &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v3 size:&quot;</span>&lt;&lt; v<span class="number">3.</span><span class="built_in">size</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v3 capacity:&quot;</span>&lt;&lt; v<span class="number">3.</span><span class="built_in">capacity</span>() &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------vector容量的重新分配--------</span><br><span class="line">v3 original address:000000331533F518</span><br><span class="line">v3 element address:000001995C508918</span><br><span class="line">v3 original size:3</span><br><span class="line">v3 original capacity:3</span><br><span class="line"></span><br><span class="line">after reserve v3, it&#x27;s address:000000331533F518</span><br><span class="line">after reserve v3, v3 element address:000001995C50A238</span><br><span class="line">v3 size:5</span><br><span class="line">v3 capacity:6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到重新分配内存后，vector的地址没有变化，但容器中的元素已经被重新分配了内存，同时内存的分配是成倍的。</p><p>此外，调用reserve()方法也会使得容器中的元素被重新分配地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//vector的创建</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1;<span class="comment">//空的vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">3</span>,<span class="number">10</span>)</span></span>;<span class="comment">//创建含有3个10的vector</span></span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;--------vector.reserve()--------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v2 original address:&quot;</span>&lt;&lt; &amp;v2 &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v2 element address:&quot;</span>&lt;&lt; &amp;(v2[<span class="number">2</span>]) &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v2 original size:&quot;</span>&lt;&lt; v<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v2 original capacity:&quot;</span>&lt;&lt; v<span class="number">2.</span><span class="built_in">capacity</span>() &lt;&lt;std::endl;</span><br><span class="line">    v<span class="number">2.</span><span class="built_in">reserve</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;after reserve v2, it&#x27;s address:&quot;</span>&lt;&lt; &amp;v2 &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;after reserve v2, v2 element address:&quot;</span>&lt;&lt; &amp;(v2[<span class="number">2</span>]) &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v2 original size:&quot;</span>&lt;&lt; v<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;v2 original capacity:&quot;</span>&lt;&lt; v<span class="number">2.</span><span class="built_in">capacity</span>() &lt;&lt;std::endl;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------vector.reserve()--------</span><br><span class="line">v2 original address:000000233F54F648</span><br><span class="line">v2 element address:000001E512AB4EE8</span><br><span class="line">v2 original size:4</span><br><span class="line">v2 original capacity:4</span><br><span class="line">after reserve v2, it&#x27;s address:000000233F54F648</span><br><span class="line">after reserve v2, v2 element address:000001E512AAE508</span><br><span class="line">v2 original size:4</span><br><span class="line">v2 original capacity:7</span><br></pre></td></tr></table></figure><h3 id="常用操作的时间复杂度">常用操作的时间复杂度</h3><ul><li><strong>push_back() / pop_back()</strong><br>时间复杂度： O(1)</li><li><strong>insert() / erase()</strong><br>时间复杂度： O(n) 与靠近头部复杂度越高，因为插入的目标位置后的元素均需要重新分配地址，随之带来的问题就是插入位置之前（或之后）的迭代器的引用、指针失效。</li><li><strong>find()</strong><br>时间复杂度：O(n)</li></ul><h3 id="优点">优点</h3><ul><li>支持随机访问；</li><li>长度可拓展</li></ul><h3 id="缺点">缺点</h3><ul><li>多次插入数据或插入大量数据时会有多次拓展vector内存的风险，造成时间上的浪费。（可以在插入前先计算好插入后的长度，使用reserve()函数重新分配内存。）</li></ul><h3 id="应用场景">应用场景</h3><p>适用于经常随机访问容器元素，在中间插入次数少、插入数据量较小的情况。</p><h3 id="迭代器失效">迭代器失效</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//vector的创建</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1;<span class="comment">//空的vector</span></span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;-----------------------vector迭代器的失效------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> iterator = v<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">    std::cout&lt;&lt;*iterator&lt;&lt;std::endl;</span><br><span class="line">    v<span class="number">1.</span><span class="built_in">reserve</span>(<span class="number">6</span>);</span><br><span class="line">    std::cout&lt;&lt;*iterator&lt;&lt;std::endl;    <span class="comment">//触发断点 can&#x27;t dereference incalidated vector iterator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表-list">链表 list</h2><p>list是一个<strong>双向链表</strong>。虽然与vector均为<strong>顺序容器</strong>，但不同的是list<strong>不支持随机存取</strong>，只能从头部或尾部一次顺序访问。插入和删除操作只会导致被删除元素的迭代器失效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//list的创建</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l1;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l2&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;-----------------------list添加元素------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    l<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    l<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    l<span class="number">1.</span><span class="built_in">insert</span>(l<span class="number">1.</span><span class="built_in">begin</span>(),<span class="number">10</span>);</span><br><span class="line">    l<span class="number">1.</span><span class="built_in">push_front</span>(<span class="number">9</span>);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;---l1---&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; item : l1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;-----------------------list删除元素------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;---l2---&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; item : l2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    l<span class="number">2.</span><span class="built_in">erase</span>(l<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line">    l<span class="number">2.</span><span class="built_in">pop_back</span>();</span><br><span class="line">    l<span class="number">2.</span><span class="built_in">pop_front</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;-----------------------list查找元素------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    l<span class="number">2.f</span>ront(); <span class="comment">//返回第一个元素</span></span><br><span class="line">    l<span class="number">2.</span><span class="built_in">rbegin</span>(); <span class="comment">//列表第一个元素的逆向迭代器</span></span><br><span class="line">    l<span class="number">2.</span><span class="built_in">begin</span>(); <span class="comment">//列表第一个元素的迭代器</span></span><br><span class="line">    l<span class="number">2.</span><span class="built_in">end</span>(); <span class="comment">//列表最后一个元素的迭代器</span></span><br><span class="line">    l<span class="number">2.</span><span class="built_in">rend</span>(); <span class="comment">//列表最后一个元素的迭代器</span></span><br><span class="line">    l<span class="number">2.</span><span class="built_in">cend</span>(); <span class="comment">//列表最后一个元素的常量迭代器</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;-----------------------list遍历------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;---l2---&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; item : l2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;---l3---&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = l<span class="number">3.</span><span class="built_in">begin</span>();i!=l<span class="number">3.</span><span class="built_in">end</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;*i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;-----------------------list迭代器失效------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//list的插入和删除不会引发像vector一样的迭代器失效</span></span><br><span class="line">    l<span class="number">3.</span><span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> iterator = l<span class="number">3.</span><span class="built_in">begin</span>();</span><br><span class="line">    std::cout&lt;&lt;*iterator&lt;&lt;std::endl;</span><br><span class="line">    l<span class="number">3.</span><span class="built_in">insert</span>(l<span class="number">3.</span><span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">    l<span class="number">3.</span><span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//l3.erase(l3.begin());</span></span><br><span class="line">    std::cout&lt;&lt;*iterator&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list的迭代器失效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;-----------------------list迭代器失效------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">   <span class="comment">//list的插入一般不会引发迭代器失效</span></span><br><span class="line">   l<span class="number">3.</span><span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">auto</span> iterator = l<span class="number">3.</span><span class="built_in">begin</span>();</span><br><span class="line">   std::cout&lt;&lt;*iterator&lt;&lt;std::endl;</span><br><span class="line">   <span class="comment">//l3.insert(l3.begin(),1);</span></span><br><span class="line">   <span class="comment">//l3.resize(10);</span></span><br><span class="line">   l<span class="number">3.</span><span class="built_in">erase</span>(l<span class="number">3.</span><span class="built_in">begin</span>());</span><br><span class="line">   std::cout&lt;&lt;*iterator&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;-----------------------遍历list+删除导致的迭代器失效------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt;::iterator iterator = l<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iterator != l<span class="number">2.</span><span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iterator % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l<span class="number">2.</span><span class="built_in">erase</span>(iterator);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++iterator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时会触发断言，这是因为已经将iterator erase掉了，迭代器就不能++了。<br>所以，需要这样写避免断言：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;-----------------------遍历list+删除导致的迭代器失效------------------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt;::iterator iterator = l<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iterator != l<span class="number">2.</span><span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iterator % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iterator = l<span class="number">2.</span><span class="built_in">erase</span>(iterator);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++iterator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="常用操作的时间复杂度-2">常用操作的时间复杂度</h3><ul><li><strong>push_back() / push_front() / pop_back() / pop_front()</strong><br>时间复杂度： O(1)</li><li><strong>insert() / erase()</strong><br>时间复杂度： O(1)<br>与靠近头部复杂度越高，因为插入的目标位置后的元素均需要重新分配地址，随之带来的问题就是插入位置之前（或之后）的迭代器的引用、指针失效。</li><li><strong>遍历or访问某一元素</strong><br>时间复杂度O(n)</li></ul><h3 id="优点-2">优点</h3><ul><li>插入、删除元素速度快</li><li>插入删除操作不会复制其他元素，改变元素地址，从一定程度上避免了迭代器失效。</li></ul><h3 id="缺点-2">缺点</h3><ul><li>内存不连续，空间利用率较低</li><li>当面对大量的元素时，遍历list会变得耗时。</li></ul><h3 id="应用场景-2">应用场景</h3><p>list适合经常插入、删除数据，数据量不大或不需要查找、遍历的情况。</p><h2 id="映射-map">映射 map</h2><p>map是基于红黑树的二元关联容器，类似C#的字典，前一个模板类用于存储键值，后一个模板类用于存储值类型。map会按键值自动排序。</p><p>每个键只出现一次，若插入元素的键已经存在，则原元素会被新插入的元素替换。</p><p>当通过访问不存在的键查找值时，map会自动创建一个新的pair元素，其键是用户给定的查找值，值将通过默认的构造函数创建，一个新的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3f</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">    <span class="built_in">Vector3f</span>():<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(<span class="number">0</span>),<span class="built_in">z</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Vector3f</span>(<span class="type">float</span> a, <span class="type">float</span> b,<span class="type">float</span> c):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b),<span class="built_in">z</span>(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3f Position;</span><br><span class="line">    <span class="built_in">GameObject</span>():<span class="built_in">Position</span>(<span class="built_in">Vector3f</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">GameObject</span>(<span class="type">float</span> a, <span class="type">float</span> b,<span class="type">float</span> c):<span class="built_in">Position</span>(a,b,c)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;out,<span class="type">const</span> GameObject &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;obj.Position.x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;obj.Position.y&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;obj.Position.z&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//create map</span></span><br><span class="line">    std::map&lt;std::string,GameObject&gt; m1;</span><br><span class="line">    <span class="comment">//insert element</span></span><br><span class="line">    <span class="function">GameObject <span class="title">obj1</span><span class="params">(<span class="number">10.f</span>,<span class="number">2.f</span>,<span class="number">1.f</span>)</span></span>;</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s1&quot;</span>,obj1));</span><br><span class="line">    m1[<span class="string">&quot;s2&quot;</span>] = <span class="built_in">GameObject</span>(<span class="number">0.2f</span>,<span class="number">0.5f</span>,<span class="number">1.0f</span>);</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s3&quot;</span>,<span class="built_in">GameObject</span>(<span class="number">2.f</span>,<span class="number">1.f</span>,<span class="number">5.f</span>)));</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s0&quot;</span>,<span class="built_in">GameObject</span>(<span class="number">-2.f</span>,<span class="number">-1.f</span>,<span class="number">-5.f</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//erase</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = m<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">    ++iterator;</span><br><span class="line">    std::cout&lt;&lt;iterator-&gt;second&lt;&lt;std::endl;</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">erase</span>(iterator);</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;iterator-&gt;second&lt;&lt;std::endl;</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s2&quot;</span>,<span class="built_in">GameObject</span>(<span class="number">100.f</span>,<span class="number">0.f</span>,<span class="number">10.f</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> ret = m<span class="number">1.f</span>ind(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">    std::cout&lt;&lt;ret-&gt;first&lt;&lt;std::endl;<span class="comment">//这一步操作触发程序断言，因为此时m1中没有“s1”键。</span></span><br><span class="line">    <span class="comment">//当试图访问一个不存在的key时，map会调用默认的构造函数，在map中添加一个元素</span></span><br><span class="line">    std::cout&lt;&lt;m1[<span class="string">&quot;s1&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;m1[<span class="string">&quot;s2&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;m1[<span class="string">&quot;s6&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;&amp;m1[<span class="string">&quot;s6&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用操作的时间复杂度-3">常用操作的时间复杂度</h3><ul><li><strong>insert() / erase() / count() / find()</strong><br>时间复杂度均为O(logN)</li></ul><h3 id="优点-3">优点</h3><ul><li>增删查的效率高</li><li>元素排列有序</li></ul><h3 id="缺点-3">缺点</h3><ul><li>使用[]查找失败时会增加map的元素数量，导致map的存储元素混乱不清</li><li>通过find()查找失败时，返回的迭代器是无效的。</li><li>删除后元素的迭代器也会失效。</li></ul><h3 id="应用场景-3">应用场景</h3><p>需要以键值对查找元素，元素保持一定的顺序时的情形可以使用map。比如，管理一个UI系统，可以使用map将枚举类和UI对应起来。</p><h2 id="无序映射-unordered-map">无序映射 unordered_map</h2><p>unordered_map是基于哈希表实现的无序容器，其不会像map一样按键值排序。</p><p>每个键只出现一次，若插入元素的键已经存在，则原元素会被新插入的元素替换。</p><p>当通过访问不存在的键查找值时，unordered_map会自动创建一个新的pair元素，其键是用户给定的查找值，值将通过默认的构造函数创建，一个新的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3f</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">    <span class="built_in">Vector3f</span>():<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(<span class="number">0</span>),<span class="built_in">z</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Vector3f</span>(<span class="type">float</span> a, <span class="type">float</span> b,<span class="type">float</span> c):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b),<span class="built_in">z</span>(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3f Position;</span><br><span class="line">    <span class="built_in">GameObject</span>():<span class="built_in">Position</span>(<span class="built_in">Vector3f</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">GameObject</span>(<span class="type">float</span> a, <span class="type">float</span> b,<span class="type">float</span> c):<span class="built_in">Position</span>(a,b,c)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bool operator &lt; (const GameObject&amp; object)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if(this-&gt;Position.x&lt;object.Position.x)</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;out,<span class="type">const</span> GameObject &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;obj.Position.x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;obj.Position.y&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;obj.Position.z&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//create map</span></span><br><span class="line">    std::unordered_map&lt;std::string,GameObject&gt; m1;</span><br><span class="line">    <span class="comment">//insert element</span></span><br><span class="line">    <span class="function">GameObject <span class="title">obj1</span><span class="params">(<span class="number">10.f</span>,<span class="number">2.f</span>,<span class="number">1.f</span>)</span></span>;</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s1&quot;</span>,obj1));</span><br><span class="line">    m1[<span class="string">&quot;s2&quot;</span>] = <span class="built_in">GameObject</span>(<span class="number">0.2f</span>,<span class="number">0.5f</span>,<span class="number">1.0f</span>);</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s3&quot;</span>,<span class="built_in">GameObject</span>(<span class="number">2.f</span>,<span class="number">1.f</span>,<span class="number">5.f</span>)));</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s0&quot;</span>,<span class="built_in">GameObject</span>(<span class="number">-2.f</span>,<span class="number">-1.f</span>,<span class="number">-5.f</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//erase</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = m<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">    ++iterator;</span><br><span class="line">    std::cout&lt;&lt;iterator-&gt;second&lt;&lt;std::endl;</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">erase</span>(iterator);</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;iterator-&gt;second&lt;&lt;std::endl;</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,GameObject&gt;(<span class="string">&quot;s2&quot;</span>,<span class="built_in">GameObject</span>(<span class="number">100.f</span>,<span class="number">0.f</span>,<span class="number">10.f</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> ret = m<span class="number">1.f</span>ind(<span class="string">&quot;s2&quot;</span>);</span><br><span class="line">    std::cout&lt;&lt;ret-&gt;first&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//当试图访问一个不存在的key时，unordered_map会调用默认的构造函数，在容器中添加一个新元素</span></span><br><span class="line">    std::cout&lt;&lt;m1[<span class="string">&quot;s1&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;m1[<span class="string">&quot;s2&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;m1[<span class="string">&quot;s6&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;&amp;m1[<span class="string">&quot;s6&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : m1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;m.first&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;m.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用操作的时间复杂度-4">常用操作的时间复杂度</h3><ul><li><strong>insert() / erase() / count()</strong><br>平均时间复杂度为O(1)，最坏情况O(n)</li><li><strong>find()</strong><br>时间复杂度O(1)</li></ul><h3 id="优点-4">优点</h3><ul><li>增删查的效率高</li></ul><h3 id="缺点-4">缺点</h3><ul><li>元素无序存储</li><li>可能存在哈希冲突</li><li>使用[]查找时会导致unordered_map数量增加</li><li>通过find()查找失败时，返回的迭代器是失效的</li></ul><h3 id="应用场景-4">应用场景</h3><p>不需要元素有序排列，且需要快速查找元素。</p><h2 id="集合-set">集合 set</h2><p>set是基于<strong>红黑树</strong>实现的简单关联容器，和数学集合的概念相似，set<strong>不允许出现相同元素</strong>，但set不能存储无限集。使用序列化的方式创建新的set本质是复制对象的值，开辟新的地址。set的元素地址是<strong>连续</strong>的。与map和unordered_map不同的是，向set中插入重复的元素并不会发生什么，原有元素并不会被新元素替代。对于自定义类型(or结构体)需要重载&lt;运算符以完成自动排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">Vector2D</span>():<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Vector2D</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">    <span class="built_in">Vector2D</span>(<span class="type">const</span> Vector2D&amp; vec):<span class="built_in">x</span>(vec.x),<span class="built_in">y</span>(vec.y)&#123;std::cout&lt;&lt;<span class="string">&quot;Copy Vector2D&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Vector2D&amp; vec) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;x&lt; vec.x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; s2&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; s3&#123;<span class="number">20</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    std::set&lt;Vector2D&gt; s4&#123;<span class="built_in">Vector2D</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">Vector2D</span>(<span class="number">3</span>,<span class="number">4</span>),<span class="built_in">Vector2D</span>(<span class="number">12</span>,<span class="number">5</span>)&#125;;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:s1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:s1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:s2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入重复元素</span></span><br><span class="line">    <span class="function">Vector2D <span class="title">vec</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    s<span class="number">4.</span><span class="built_in">insert</span>(vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:s4)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;ele.x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;ele.y&lt;&lt;<span class="string">&quot;||&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内存地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:s1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&amp;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">auto</span> it = s<span class="number">1.f</span>ind(<span class="number">2</span>);</span><br><span class="line">    std::cout&lt;&lt;*it&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set的元素地址是连续的，但set的删除操作并不会引发其他元素的移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000022E37</span>DA8EAC <span class="number">0000022E37</span>DA902C <span class="number">0000022E37</span>DA932C <span class="comment">//未进行操作的s1内存地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:s1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&amp;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">auto</span> it1 = s<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">    it1++;</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">erase</span>(it1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:s1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&amp;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000016</span>F4B37821C <span class="number">0000016</span>F4B3781BC <span class="number">0000016</span>F4B37827C</span><br><span class="line"><span class="number">0000016</span>F4B37821C <span class="number">0000016</span>F4B37827C</span><br></pre></td></tr></table></figure><h3 id="常用操作的时间复杂度-5">常用操作的时间复杂度</h3><ul><li>插入、删除、查找<br>时间复杂度均为O(logN)</li></ul><h3 id="优点-5">优点</h3><ul><li>插入元素自动排序，保证集合有序性</li></ul><h3 id="缺点-5">缺点</h3><ul><li>对于成员变量均为非数值型的类或结构体来说需要找到一个合适的变量用于比较大小进行排序的目的。（可以字符或id，字符可能会程序员被混淆，而增加id又需要一个额外的空间存储）</li><li>元素很少时，查找删除插入等操作的效率较低。</li></ul><h3 id="应用场景-5">应用场景</h3><ul><li>需要元素有序且唯一的场景。与map类似</li><li>也可用于剔除一些重复的元素（比如，构建布料结构时的需要剔除重复的）</li></ul><h1>关于迭代器失效</h1><p>迭代器是一个用于存储数据的模板类，成员变量包含一个指向模板数据的指针。迭代器失效本质是指向数据的指针为空。造成迭代器失效的原因是对STL进行操作时，内部数据地址变化引发的问题。因此由删除等操作引发的内部数据地址的变化的操作都会引发迭代器失效。特别是vector、map、set等有特殊结构的容器都可能触发迭代器失效。</p><p>对于vector容器，在中间插入，删除会导致插入位置后面的数据内存地址发生变化，而扩容则会导致容器内的数据被复制到其他内存中。从而使迭代器失效。</p><p>对于其他容器，删除一个数据可能引发数据结构的变化，也就是说数据的内存地址发生了变化。比如map的本质是一棵红黑树，删除一个数据，树会自平衡，从而数据内存发生变化。</p><p>迭代器失效常见于在循环中删除数据这一操作，比如上面map、set、unordered_map、list中的错误均属这一类。为避免这种错误，可以使用break跳出循环体，或者将迭代器重新赋值。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 基础汇总</title>
      <link href="/2024/07/19/C&amp;CPP%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/07/19/C&amp;CPP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>鄙人进入大学后才正式学习编程，加之中国传媒大学的计算机课程安排凌乱结课要求低，因此基础知识仍然不成体系不够扎实。故写一写博客用于输出学到的内容，整理面试时被问到的问题。</p><h1>往期内容</h1><ul><li><font size="4"><a href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP/" title="C++面向对象编程OOP">C++面向对象编程OOP</a></font></li><li><font size="4"><a href="/2024/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88/" title="C++中的指针">C++中的指针</a></font></li><li><font size="4"><a href="/2024/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="C++中的智能指针">C++中的智能指针</a></font></li><li><font size="4"><a href="/2024/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++STL%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" title="C++STL的优缺点以及应用场景">C++STL的优缺点以及应用场景</a></font></li><li><font size="4"><a href="/2024/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C++STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" title="C++STL常用算法">C++STL常用算法(施工中。。。)</a></font></li></ul><h1>参考资料</h1><ul><li>中国传媒大学 《面向对象游戏程序设计》 课程PPT</li><li>中国传媒大学 《游戏开发程序设计基础》 课程PPT</li><li><a href="https://web.stanford.edu/class/cs106l/">斯坦福大学 CS106</a></li><li><a href="https://www.bilibili.com/video/BV1oD4y1h7S3/">Chorno的C++课程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见布料模拟方法 Cloth Simulation</title>
      <link href="/2024/07/17/%E5%B8%B8%E8%A7%81%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95-Cloth-Simulation/"/>
      <url>/2024/07/17/%E5%B8%B8%E8%A7%81%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95-Cloth-Simulation/</url>
      
        <content type="html"><![CDATA[<p>本文整理了布料模拟实践过程中学习到的各种理论方法，记录了实践过程中遇到的问题和解决办法。主要基于Unity完成了基于显示欧拉法和PBD方法的布料模拟，并使用ComputeShader对模拟过程的加速。</p><h1>实现思路</h1><h2 id="思路概述">思路概述</h2><p>计算机图形学中的物理模拟方法可以笼统概括为三个阶段：初始化阶段，物理模拟阶段，更新数据阶段。</p><p>初始化阶段中需要构建物理模型。在开始模拟前需要先理解一块布的结构，一块布中存在结构力、剪切力以及弯曲力（图），根据这一结构特点可构建质点弹簧模型，据此模型计算质点间的相互作用完成模拟。</p><p>物理模拟阶段的具体实现方法很多，分为两个主要流派，分别是基于物理的模拟和非物理的模拟。</p><p>物理模拟方法以欧拉法为主。在质点弹簧系统中，根据胡克定律计算质点间的力，更新质点加速度、速度、位置。欧拉法具体有显示欧拉法、半隐式欧拉法和隐式欧拉法，区别在于显示欧拉法使用t时刻受到的合力更新t+1时刻的位置，隐式欧拉法使用t+1时刻受到的合力更新t+1时刻的位置，半隐式欧拉法结合显示欧拉法和隐式欧拉法，通过t时刻受到的合力更新更新t+1时刻的速度，使用该速度更新t+1时刻的位置。显示欧拉的方程是线性的，隐式欧拉的方程是非线性的。通常来说求解非线性方程，可以使用数值分析，比如将非线性方程转换后可以用牛顿迭代的方法求解最小值，或者使用龙格库塔方法进行求解。从稳定性角度来讲，显示欧拉法是条件稳定的，在时间步长较小时可以保持稳定，但当时间步长增大误差就会累积从而失去稳定性。此外随着模拟时间增加，误差也会累积使得出现模拟错误。隐式欧拉法理论上是无条件稳定的，但由于通常使用线性方式近似求解所以也是条件稳定的，仍需控制时间步长进行才能保证模拟稳定运行。</p><p>非物理模拟方法中常见的有基于位置的动力学模拟方法（Position-Based Dynamics，PBD）。主要思路是通过欧拉法预测下一时刻位置，再施加约束进行修正，PBD方法不仅可以用到布料模拟中，而且可以用到软体模拟等模拟中。作者给出了PBD方法的主要思路和框架，只需要确定约束方程，并将约束方程加入到约束列表中解约束即可。从稳定性方面看，与欧拉法相比PBD方法更为稳定，但也不是无条件稳定的，其稳定性也受迭代次数、时间步长的影响。</p><p>数据更新阶段需要将更新好的位置、速度重新赋给模型顶点，然后绘制图形。</p><h2 id="质点弹簧系统的构建">质点弹簧系统的构建</h2><h3 id="结构化网格">结构化网格</h3><p>结构化的网格手动计算每个顶点的初始位置，构建三角形，以及三角形索引。然后为每个三角形每一条边边构建一个弹簧。在此之前，为了防止重复构建弹簧，需要剔除重复边。</p><h3 id="非结构化网格">非结构化网格</h3><p>非结构化的网格直接读取Mesh中的顶点、三角形索引等数据。再为每个三角形的每一条边构建一条弹簧。同样地为了防止重复构建弹簧，需要剔除重复边。非结构化网格可以用于任意网格的模拟。</p><h2 id="物理模拟过程">物理模拟过程</h2><p>实践中实现了显示欧拉和PBD方法的物理模拟。下面给出伪代码。</p><h3 id="显示欧拉">显示欧拉</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreall vertices i</span><br><span class="line">velocityt+1 = velocityt + dt*at;</span><br><span class="line"> positiont+1 = positiont + dt*velocityt;</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h3 id="PBD方法的物理模拟">PBD方法的物理模拟</h3><p>PBD方法的模拟流程如下：</p><h4 id="高斯-赛德尔迭代法（Gauss-Seidel-Iteration）">高斯-赛德尔迭代法（Gauss-Seidel Iteration）</h4><p>高斯-赛德尔迭代法每次迭代中立即使用求解得到新值进行计算。在模拟中体现为遍历每一条边，通过调整每条边两顶点位置，以及边所属的正方格实现对预测位置的修正。</p><p>问题：如果一个正方形网格中只构建一条剪切弹簧，那么会出现布料向一侧变形的错误结果。这是由于Gauss-Seidel迭代以弹簧顺序进行，调整下一根弹簧后上一根弹簧调整过的顶点也会发生移动。</p><h4 id="雅可比迭代法（Jacobi-Iteration）">雅可比迭代法（Jacobi Iteration）</h4><p>雅可比迭代法又称同时迭代法，通过将线性方程的对角矩阵变换为对角矩阵及其他部分，可在每次迭代中直接求得解。体现在模拟过程中为不再需要预测位置而是直接通过解方程得到模拟位置。雅可比迭代法相比高斯赛德尔方法对并行计算更加友好，且不容易发生布料形变的问题。</p><h1>实现方法</h1><h2 id="数据结构">数据结构</h2><h3 id="显示欧拉-2">显示欧拉</h3><h3 id="Gauss-Seidel">Gauss-Seidel</h3><h3 id="Jacobi">Jacobi</h3><h2 id="布料构建">布料构建</h2><h2 id="布料模拟">布料模拟</h2><h3 id="欧拉法">欧拉法</h3><p>计算位置<br>计算速度<br>碰撞响应</p><h3 id="PBD-Gauss-Seidel">PBD Gauss-Seidel</h3><p>距离约束<br>弯曲约束<br>碰撞约束</p><h3 id="PBD-Jacobi">PBD Jacobi</h3><p>约束方法<br>碰撞响应</p><h2 id="GPU模拟">GPU模拟</h2><h3 id="计算着色器（Compute-Shader）">计算着色器（Compute Shader）</h3><p>DirectX 11、OpenGL 4.3后新增了计算着色器。GPU除了可以进行传统光栅化管线还可以利用GPU的架构进行并行运算，完成后处理效果、粒子系统等功能。Compute Shader是独立于Vertex Shader和Fragment Shader的管线。</p><h3 id="写入冲突与原子操作">写入冲突与原子操作</h3><p>在调用计算着色器中的函数需要在CPU端进行，使用Dispatch()调用计算着色器函数，用户可以指定运行的线程组数量。一个线程组包含多个线程，运行时GPU上的多个线程组就会同时无序运行。如果两个弹簧结构中有同一个顶点的索引，在向该顶点写入数据时可能会有多个线程向同一地址的数据写入的情况，使得写入失败。</p><p>对于这种情况可以考虑原子操作，在CS中对于int和uint类型的数据可以使用一系列InterLock()函数避免该情况，但因为位置、速度等都是三维浮点数就需要做出调整。这里参考了别人的解决方法，大概是将要写入的数据转为uint类型，计入临时Buffer中，最后更新数据阶段再从Buffer中读取。</p><h1>实现框架</h1><p>基于Unity实现，渲染部分由Unity绘制。C#脚本负责初始化数据及设置计算着色器的Buffer，计算着色器负责处理并行</p><h1>效果显示</h1><h2 id="测试设备">测试设备</h2><p>CPU：12th Gen Intel® i9-12900HX<br>GPU: NVIDIA GeForce RTX 3080 Ti</p><h2 id="效果演示">效果演示</h2><p>请移步B站： <a href="https://www.bilibili.com/video/BV1qabLeME4p/">https://www.bilibili.com/video/BV1qabLeME4p/</a></p><h1>未完成的工作</h1><h2 id="未完成布料的自相交">未完成布料的自相交</h2><p>虽然PBD文献中给出了布料自相交的约束公式，但每个顶点需要和每个三角形进行碰撞检测放在GPU上就不好实现。看到了一些方法比如可以用BVH树加快这一过程，但在GPU中构建树又是难度较高的事。因此这部分还没来得及完成。</p><h2 id="未完成在GPU中直接绘制布料">未完成在GPU中直接绘制布料</h2><p>用户可以调用DrawProceduralIndirect()在GPU程序化绘制几何图形，以此节约从GPU读取Buffer数据到CPU这一过程的时间。个人一直掌握不好这个函数的用法，常常绘制出不合预期的图形或根本绘制不出图形。故还没有应用到项目中。要不然在GPU端的模拟帧率还可以继续提升。</p><h1>参考文献及资料</h1><p>[1] Matthias Müller, Heidelberger B, Hennix M, etal. Position Based Dynamics[J]. VRIPHYS, 2006(3).<br>[2] WU L, WU B, YANG Y, etal. A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions[J]. ACM, 2020, 1(1).<br>[3]GAMES103<br>[4] 迭代法求解线性方程 （简单迭代法 雅可比(Jacobi)迭代法 高斯-塞德尔(Gauss-Seidel)迭代法 逐次超松弛(SOR)迭代法） <a href="c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%89%88">数值计算方法</a>_高斯-雅可比-CSDN博客<br>[5] PBD（Position Based Dynamics）学习笔记_pbd算法-CSDN博客<br>[6] wlgys8/GPUClothSimulationLearn: Unity GPU布料物理模拟入门 (<a href="http://github.com">github.com</a>)<br>[7] wlgys8/PBDClothLearn: Cloth Simulation by Position Based Dynamics + Unity Job System (<a href="http://github.com">github.com</a>)<br>[8] Solicey/UnityPBDClothSimulationOnGPU: Cloth simulation based on Position Based Dynamics (PBD) in Unity, using compute shaders (<a href="http://github.com">github.com</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理仿真 </tag>
            
            <tag> 软体模拟 </tag>
            
            <tag> Position Based Dynamics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《战神4》中的图形学技术——风场和植被交互系统</title>
      <link href="/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E9%A3%8E%E5%9C%BA%E5%92%8C%E6%A4%8D%E8%A2%AB%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E9%A3%8E%E5%9C%BA%E5%92%8C%E6%A4%8D%E8%A2%AB%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>简单的风力与植被交互系统</h1><p>一些基础教程通过自定义顶点着色器实现对植被面片模型的顶点扰动。简单的方法是根据时间对一张噪声纹理进行位移和缩放上的变化。依据遮罩纹理限制顶点变化值，再将变化值附加到原先的顶点位置上，从而实现植被的随风摆动效果。</p><p>至于与植被的交互则是需要记录玩家的行动轨迹Render Texture，根据Render Texture的信息对周围植被做出响应。</p><p>当然这只是简单的植被材质的实现。在此基础上可以做到更为复杂且看起来真实的效果。但是仅仅简单的方法不能满足角色挥砍武器等动作与植被的交互。同时这种实现方法的植被很容易就会感到重复，为玩家带来的代入感就会降低。</p><h1>《战神4》中的风力与植被交互系统</h1><h2 id="风场的表达">风场的表达</h2><p>结合上面提到的植被交互系统的优缺点，《战神4》制作组提出了明确的目标，需要清晰展现随时空变化风力的变化以及玩家交互。</p><p>在深入探讨如何表达风前，我们需要对风有更加深刻的认识。风可以看作一个场，这个场将位置映射到风力，风力自然是有大小和方向的矢量，且这个矢量会随着时间和空间变化。从最直观感受上看，生活中同一个位置的不同时刻风的方向和强弱均在发生变化，而同一时刻的不同位置风力自然也会有所区别。</p><p>理解了现实中的风，再来思考游戏中的风是如何表达的就简单了。《战神4》中的风场可以看作由环境风场与可交互风场两部分共同作用而成。环境风场采取和传统意义风场相近的方式来表示，即通过采样噪声纹理（Noise Texture）获取风力的大小与方向，再将数值输入给植被。可交互风场其实是只存在于玩家周围的一个Box Volume，它会跟随玩家并记录角色——包括玩家和敌人——的一系列行为对周围风场的影响。</p><h3 id="环境风场">环境风场</h3><h4 id="生成用于环境风场的噪声纹理">生成用于环境风场的噪声纹理</h4><p>噪声纹理就是用于描述游戏中的环境风场的。常见的噪声算法有Perlin noise、Voronoi noise、Worley noise等。《战神4》制作组设计了一个多层噪声函数（Fractal Noise Function）（图1）。该函数固定不同参数下噪声纹理的缩放和频率，当参数发生变化时通过对数分箱的方式（Logarithmic Binning）（图2）获取其他噪声纹理并按权重融合，于是便得到了一个参数变化时噪声变化相对平缓逼真的效果。</p><p><img src="https://s2.loli.net/2024/07/15/bKBDZNc4Ao6Xu72.png" alt="图1.多层噪声" title="图1.多层噪声"></p><p><img src="https://s2.loli.net/2024/07/15/usiALCUgRYNXfJv.png" alt="图2.Log Binning" title="图2.Log Binning"></p><h4 id="噪声纹理的循环">噪声纹理的循环</h4><p>当我们得到噪声纹理后，还需要获取噪声纹理的信息。如果只是随时间移动纹理，以实现受到风力影响的效果，这样会有效果重复的缺点。为了解决这样的问题《战神4》加入了三个额外的处理。首先在达到纹理边界时重设采样位置，其次是重设采样位置时需要对结果进行融合处理，最后重设采样位置时不再返回初始位置，而是随机生成一个新的位置并以相同方向和速度移动纹理。这样就获得了看起来随机且没有循环的环境风场。</p><h3 id="可交互风场">可交互风场</h3><h4 id="可交互风场的定义">可交互风场的定义</h4><p>《战神4》将其称作Wind Simulation Volume，其本质是一个Box Volume。这个体积会包裹住玩家的周围环境，在这个范围内将玩家的动作信息写入纹理中。在这里可以使用3D纹理或者多张2D纹理，区别在于3D纹理是连续的，多张2D纹理是离散的，《战神4》使用的是多张2D纹理。通过记录体积内xyz轴风力的信息，将纹理做模糊处理后就可以根据记录的信息做对应的反馈了。</p><p><img src="https://s2.loli.net/2024/07/15/u5iEhVnC7SPopLR.jpg" alt="图3. Wind Simulation Volume" title="图3. Wind Simulation Volume"></p><p><img src="https://s2.loli.net/2024/07/15/gBdWASs4ExpLC3H.jpg" alt="图4. 使用纹理记录可交互风场信息" title="图4. 使用纹理记录可交互风场信息"></p><h4 id="影响风场的风力产生器">影响风场的风力产生器</h4><p>下面先解决如何记录信息到纹理的问题。《战神4》定义了三种类型的基础几何体，分别是球体、圆柱体、圆锥体。另外定义了四种风力模式，通过修改这些几何体的旋转、位置再根据风力模式就能获得响应的风力信息。四种模式分别是：直线（Directional）、扩散（Omni）、漩涡（Vortex）、触发（Wake Motor）。直线模式与风力的方向相同，扩散模式以形状中心向四周扩散，漩涡模式围绕形状中心旋转，触发模式就是据速度动态调整风力大小，通常是其他模式叠加起来完成的效果。</p><h2 id="风场作用的对象">风场作用的对象</h2><h3 id="音频">音频</h3><p>音频方面的反馈是通过WWISE音频系统实现的。《战神4》开放了风力速度等参数，音频发射器会接收这些参数，根据WWISE系统的属性实现不同的混音效果，从而实现类似多普勒效应的效果。</p><h3 id="布料">布料</h3><p>虽然这部分的工作并没有应用到最后的发行版中，但却进行了相关的实践工作。具体的实现是每块布料会拿到作用于当前布料的大小，然后将力分配到每个顶点上，再投影到顶点法向量上，最后顶点更新位置。其实本质和布料模拟中的欧拉法大致相近，都是通过分析力然后计算速度更新位置。替代的这一做法是使用预先设定好的布料动画，或者将布料算作网格一类的反馈中。</p><h3 id="粒子">粒子</h3><p>粒子只会受到可交互风场的影响，每个粒子会采样其位置下的风速和风向，每帧计算粒子的冲击力使得风速与粒子速度同步。另外还需要根据风速缩放粒子噪声的扰动参数。</p><h3 id="网格">网格</h3><p>这部分可以从两个方面和五个组件介绍。</p><p><img src="https://s2.loli.net/2024/07/15/WAH2o3xXMCZhyB5.png" alt="图5.美术技术任务分配" title="图5.美术技术任务分配"></p><h4 id="美术部分">美术部分</h4><p>美术的主要职责是提供顶点数据和不同植被的相应参数。</p><h5 id="顶点数据">顶点数据</h5><p>美术需要提供植被的遮罩数据以及面片模型的顶点数据。<br><img src="https://s2.loli.net/2024/07/15/zmiKyNHMQTWFPbG.png" alt="图6.顶点数据" title="图6.顶点数据"></p><h5 id="模型参数">模型参数</h5><p>模型数据则十分繁杂。对非树木类的模型参数有密度（Density）、运动影响因子（Movement Scale）、弯曲（Bend）、拉伸（Stretch）、刚度（Stiffness）、摆动弹力（Sway Spring）、摆动阻尼（Sway Dampen）。对于树木类的模型在此基础上还有树木模式（Tree Mode）、树木弯曲度（Tree Bend）、树木运动影响因子（Tree Movement Scale）、树叶延迟（Tree Leaf Lag）。</p><h4 id="技术部分">技术部分</h4><p>技术部分需要在顶点着色器中处理顶点数据，并根据植被参数进行顶点的偏移。在计算着色器中则需要根据参数和给定的纹理计算不同植物的分布，并通过GPU Instance实例化大量的植被。</p><h5 id="顶点着色器">顶点着色器</h5><p><strong>密度（Density）</strong> 两个密度参数，一个控制高速时的密度，一个作用于低速时的模型形态。</p><p><strong>运动影响因子（Movement Scale）</strong> 距离原始顶点位置的缩放。</p><p><strong>弯曲（Bend）</strong> 控制植被弯曲时的形态。</p><p><strong>拉伸（Stretch）</strong> 拉伸前记录原长，将位移量加到顶点位置上，在线性插值到原长，依次替代了对面片做旋转的复杂运算。拉伸系数影响这一步线性插值的大小。</p><p><strong>刚度（Stiffness）</strong> 与布料中的刚度相同，越高植物看起来越硬。</p><p><strong>摆动弹力（Sway Spring）</strong> 和<strong>摆动阻尼（Sway Dampen）</strong> 决定拉伸回原长时的作用力。</p><p><strong>树木模式（Tree Mode）</strong> 开启则会使树干受到风的影响。</p><p><strong>树木弯曲度（Tree Bend）</strong> 作用同前文的Bend参数，控制树木的弯曲程度。</p><p><strong>树木运动影响因子（Tree Movement Scale）</strong> 作用同前文的Movement Scale参数，控制距离原始顶点位置的缩放。</p><p><strong>树叶延迟（Tree Leaf Lag）</strong> 当树叶停止受到风的作用后，树叶回到原位后还会有些许晃动。当该参数越大晃动时间越长幅度越大。</p><h5 id="计算着色器">计算着色器</h5><p>计算着色器的主要任务就是生成环境风场的噪声纹理，并对其进行采样。主要就是依据前文所述方法进行采样，当采样位置到达纹理边界时，随机更新采样位置的坐标，并融合初始和结束位置的采样结果，以相同的方向和速度改变纹理的偏移量。有时采样点会有多个，于是可以使用Flow Mapping令其它采样点跟随某个采样点共同移动。但当采样点的移动速度不同时会造成明显的视觉错误。这是由于偏移量的改变速度不同造成的重设采样位置时刻不同导致的。解决这一问题是控制不同位移速度的采样点在淡出时的速度使得最终在统一时刻更新采样位置。</p><h5 id="实例化">实例化</h5><p>使用HLSL的DrawIndexInstanced直接绘制植被模型以及人物头发。避免了实时渲染时CPU不断向GPU传输数据的费时过程。</p><h3 id="毛发（头发、皮毛、胡子）">毛发（头发、皮毛、胡子）</h3><p>对于头发来说，给定了几个在角色头皮上的锚点（不是网格顶点），将风力对顶点的偏移量赋给锚点的偏移量，然后再单位化。还有两种方法就是通过对网格顶点的移动实现头发的飘动，或者将前两个方法融合使用。</p><p>对于皮毛来说，大体和头发相近，但在单位化时需要对所有面片模型进行单位化。</p><p>对于胡子来说，一个角色的胡子由多个面片模型组成，不同的面片模型具有不同的参数。在受风力影响时与皮毛是相近的处理过程。</p><h2 id="角色碰撞">角色碰撞</h2><p>《战神4》尝试了多种角色碰撞方案，记录角色行动轨迹，记录双脚轨迹等，但效果都不尽如人意。单纯记录角色行动轨迹会有台阶处的植被没有碰撞却发生碰撞反馈的情况，记录双脚轨迹则十分消耗性能且对翻滚动作没有反馈。于是想到了记录深度和行动轨迹结合的方法。</p><p>一张纹理使用两个通道，一个用于记录当前走过的深度，一个用来记录深度的淡出（图7）。对发生碰撞的草会向碰撞的方向偏移其顶点然后进行单位化，和上面提到的Stretch参数影响植被模型的过程相同。</p><p>对于大型角色和主要角色，碰撞体使用简化的多边形，小型角色使用其原本的网格碰撞体</p><p><img src="https://s2.loli.net/2024/07/15/xMhmpfLCkXn3ISr.jpg" alt="图7.角色运动轨迹纹理示意（右侧白色是淡出深度，红色是实时深度）" title="图7.角色运动轨迹纹理示意（右侧白色是淡出深度，红色是实时深度）"></p><h2 id="性能优化">性能优化</h2><h3 id="LOD">LOD</h3><p>主要介绍了植被的LOD。当植被与摄像机距离远时使用低面片组成的植被，距离近时过渡到高面片的植被模型[9]。</p><p>这里运用了Card Cluster技术，通过程序化的方式构建不同层次细节面片模型。可以将6面的植被模型压缩到了2。构建方法如下：</p><p><strong>A．</strong> 检测空间中所有的面<br><strong>B．</strong> 将距离较近的面投影到同一面上<br><strong>C．</strong> 面积最大且对其他面弯曲最小的面为下一层次的主面<br><strong>D．</strong> 回到A直到面片数达到限制</p><p><img src="https://s2.loli.net/2024/07/15/mtufkeE8HwAGSqI.png" alt="图8.构建面片模型" title="图8.构建面片模型"></p><h3 id="黑边修复">黑边修复</h3><p>通常的做法是在原图像基础上进行扩大模糊。虽然效果很好但速度比较慢，边缘还会有颜色偏差，玩家一般也不会注意到。</p><p>《战神4》选用的方法名为Mip Flooding。首先对纹理做Mip处理直到只有一个像素颜色，并记录这一过程中所有的压缩纹理。然后根据原图的alpha值进行筛选，对小于某一alpha的位置替换为对应的压缩纹理的颜色，得到的是四周经过压缩而中间清晰的纹理。这样的速度快，且压缩得比模糊处理好，占用的空间资源更少。</p><h1>参考资料 References</h1><p>[1] <a href="https://www.bilibili.com/video/BV1DF411H7W6/">SeanFeeley. Interactive Wind and Vegetation in GodofWar[R]. SMS:GDC, 2019.</a><br>[2] Xavier Décoret, Frédo Durand, François X. Sillion, 等. Billboard Clouds for Extreme Model Simplification[J]. HAL Open Science, 2010(1).<br>[3] <a href="https://www.jianshu.com/p/99f4775c93b9">球谐函数、编解码球谐系数，以及对Light Probe的重建和压缩 - 简书 (jianshu.com)</a><br>[4] <a href="https://yangwc.com/2021/06/12/SSR/">高质量实时渲染：实时全局光照 | YangWC’s Blog</a><br>[5] <a href="https://blog.csdn.net/toughbro/article/details/96724936">[gdc19]《战神4》的风力&amp;植被交互系统_战神 gdc分享-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏案例分析——技术向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《战神4》中的图形学技术——全局光照</title>
      <link href="/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"/>
      <url>/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h1>全局光照技术</h1><h2 id="全局光照的定义">全局光照的定义</h2><p>全局光照（Global Illumination，GI）或称间接光照（Indirect Illumination）。GI可以分为直接光照和间接光照两部分，通常要考虑直接受到光源照射的能量和反射光源产生的能量的总和。</p><p>为了更好理解和分析《战神》中的全局光照技术，下面先介绍一下GI的技术发展路线。</p><h2 id="全局光照的技术发展路线">全局光照的技术发展路线</h2><p>在光栅化渲染管线中，我们需要将场景中的模型数据准备好后输入顶点着色器中，经过细分曲面着色器、几何着色器、光栅化、片元着色器等操作拿到输出图像。这一过程中并不涉及间接光照。直到光线追踪技术的出现。</p><p>光线追踪的思想本质就是从屏幕投射一条光线，光线会经过不断的反射、折射直到打到光源，对物体的着色就是在这一过程中不断积分能量并计算渲染方程。</p><h3 id="光线投射（Ray-Casting）">光线投射（Ray Casting）</h3><p>光线投射由Arthur Appel在一篇名为《 Some techniques for shading machine rendering of solids》中提出。这是光线追踪的第一步，需要将屏幕空间转换到世界坐标下，然后以每个像素为起点向场景中发射一条光线，并根据与光线相交的第一个物体表面的能量进行渲染。</p><h3 id="光线追踪（Ray-Tracing）">光线追踪（Ray Tracing）</h3><p>Whitted-Style光线追踪在光线投射的基础上使用了递归式的光线追踪。当光线与材质表面相交时根据不同表面进行计算。例如，如果材质是反射就计算光线的出射光线并发射出射光线继续进行渲染。</p><h3 id="路径追踪（Path-Tracing）">路径追踪（Path Tracing）</h3><p>1986年，Kajiya提出了路径追踪方法[1]。路径追踪在Whitted-Style光线追踪的基础上做了一些调整修改。一个修改是光线的反射不再是简单的计算入射角和出射角，而是考虑一个反射光线组成的半球，对半球进行采样，随机选择可能出射光线继续追踪。另一个改进是当光源为面光源时采用了蒙特卡洛积分的方法计算光线的贡献。另外Kajiya最重要的贡献是建立了渲染方程理论。</p><p>式中，<br>Lo指x位置处具有的总能量<br>Le指x位置处自发光的能量<br>后面的积分表示x位置处接收从w’方向传播来的能量。fr是材质的BRDF公式。</p><p>Kajiya的路径追踪方法已经将直接光照和间接光照考虑进去了，可以说已经实现了全局光照。虽然可以采取KDTree或BVH等加速结构进行光线求交这一过程进行加速，但是当时的方法还只能用在离线渲染上，远远不能达到实时渲染的帧率要求。Kajiya方法的问题主要是在反射光线时采样时随机的，并没有考虑光线的重要性。因此为了结果看起来没有很多噪点除了后处理的方式降噪就只能增加每次采样时的次数。而增加采样次数就会造成投射光线的数量指数级增长，严重拖慢渲染速度。</p><p>所以一些蒙特卡洛Ray Tracing的实践工作主要集中在重要性采样上。一种简单的方法是均匀采样，即光线达到某物体表面后均匀选取该点周围的光场信息，沿对应方向投射光线。但均匀采样很可能恰好略过重要的微小光源，使得结果不正确。更好的方法是使用概率分布函数（Probability Distribution Function，简称PDF）进行重要性采样，选取能量较高且较为集中方向投射光线。</p><h3 id="动态全局光照与流明（Lumen）">动态全局光照与流明（Lumen）</h3><p>以上的GI全部用于离线渲染，为了能够实时进行全局光照的计算，许多图形工作者做出来很多工作。</p><h4 id="Reflective-Shadow-Maps（RSM）">Reflective Shadow Maps（RSM）</h4><p>RSM一定程度上结合了Shadow Map的生成方式和光子映射（Photon Mapping）的思想[2]。主要内容是用一个相机在光源处沿光照方向渲染一张纹理，其记录了光源直接照射某一位置（为了相机移动时方便计算，一般使用世界坐标系）的深度、世界坐标系下的顶点位置、法线、反射通量（flux）等。经过计算可以得出被遮挡物体在其他间接光源作用的接收的能量积分。</p><p><img src="https://s2.loli.net/2024/07/16/mHa5e3dvOGuz6kg.png" alt="RSM示意图" title="RSM示意图"></p><p><img src="https://s2.loli.net/2024/07/16/gIRzcBFTM3aSLks.png" alt="RSM公式" title="RSM公式"></p><p>RSM公式中Φp表示光源辐射通量。</p><p>获取到纹理后还需要对纹理进行采样。当我们将x点投影到xp对应的纹理坐标时记录该点的uv坐标为（s，t），随后以（s，t）为中心r为半径进行采样（实际是在做Cone Tracing，Cone Tracing就是以一跟光线为中心的）。原文选择使用极坐标表示。ξ1、ξ2分别为均匀随机数，则采样像素位置则可以表示为<br>（s+rξ1（sin（2πξ2）），t+rξ2（cos（2πξ1）））</p><p>为了使采样点更加均匀还要再除以ξ12进行修正。在采样数为400左右时便可以得到不错的效果了。</p><p>但是RSM方法也有不少缺陷。首先每个灯光都需要一张RSM进行描述，其次没有考虑到灯光的可见性，当一个RSM中出现其他灯光时会有一些视觉上的错误。</p><h4 id="Light-Propagation-Volumes（LPV）">Light Propagation Volumes（LPV）</h4><p>LPV方法基于光照辐射率在三维空间中沿直线传播且传播过程中辐射率不变[3]。LPV的思想是将三维场景均匀体素化（不是物体体素化），记录每个体素的辐射度（radiance），将其转换为一个二阶的球谐函数。在着色时计算着色点的辐照度（irradiance）。</p><h4 id="Voxelization-Based-Global-Illumination（VXGI）">Voxelization Based Global Illumination（VXGI）</h4><p>VXGI是UE4中使用的实时全局光照技术。另外同样使用体素化思想进行全局光照渲染的方法还有Sparse Voxel Octree Global Illumination（SVOGI）。前者使用Clipmap的方式存储体素，后者使用八叉树存储体素。这两种方法在物体发生变化时都需要重新构建体素，而八叉树的构建或调整是复杂且较为缓慢的，Clipmap的重建调整则相对简单迅速。另一方面，SVOGI使用Mip-map存储体素信息，一些与相机距离较远的体素也存储了较高分辨率的体素信息，而这部分信息很可能是用不到或者很少用到的，就会造成一定的内存浪费。Clipmap在此基础上进行优化，只对中心的光照信息进行Mip-map操作，节约了许多内存空间。可以说VXGI优于SVOGI方法，这里也只介绍VXGI方法。</p><p><img src="https://s2.loli.net/2024/07/16/GdPkt5BqswaxZc9.jpg" alt="Clipmap与Mip-map" title="Clipmap与Mip-map"></p><p>Clipmap在构建时会将三角形投影到xy、xz、yz三个面上，同时记录透明度、颜色、法线、自发光等信息到3D纹理中，对于一个体素包含多个三角形的情况则会取这些三角形属性的平均值。在距离相机较近的位置使用更加精细的体素，在较远的位置使用体积较大的体素。由于近大远小，这些体素看起来大小差距并不大。</p><p><img src="https://s2.loli.net/2024/07/16/loCt6RLizDwFm8x.jpg" alt="VXGI构建好的场景" title="VXGI构建好的场景"></p><p>构建好体素后，使用RSM的方法拿到纹理，收集每个体素接收到的能量。接下来在每一次Bounce时使用Cone Tracing代替单独一根光线的投射。Cone Tracing就是将一根光线换做有一定角度的圆锥。例如，对于一个半球可以使用多个ConeTracing进行概括描述。对于很锐利的高光则可以使用单一的小夹角的Cone进行描述。在实际反射中会根据材质进行数量、角度上的调整。如果材质是漫反射的，则会在半球上分布多个大夹角的Cone，如果是高光，则只使用一个Cone对出射光线进行描述。</p><p><img src="https://s2.loli.net/2024/07/16/Fty73sd1kP5gOIj.png" alt="Cone Tracing" title="Cone Tracing"></p><p>那么替换原先的光线后又应该判断与体素是否发生相交呢？这里使用形似Ray Marching的方法。首先定义一个光锥，记其起始点为C¬o，投射方向为Cd，圆锥体角θ，某时刻光线长度t。<br>则某时刻圆锥底面半径为：r = t⋅tan(θ/2)，假设有一以圆锥底面圆心为中心，r为半径的球，我们需要构建一个与这个球相切的正方体，将整个球包裹在其中。<br>因此正方体边长为：d =2⋅r = 2⋅t⋅tan(θ/2)<br>根据正方体的边长我们就可以计算出需要在哪一层级的纹理进行采样了。<br>level =  log2（d/Vsize）,其中Vsize是Mip-map的最高层数。</p><p><img src="https://s2.loli.net/2024/07/16/c8yhzTvFeUmBaH9.png" alt="Cone Tracing中的光线步进" title="Cone Tracing中的光线步进"></p><p>VXGI也存在一些问题，比如3D纹理的存储浪费资源；以及当大尺寸体素中的物体比较小时则会发生Cone与其相交但光线从中漏过的情况，从而产生漏光（Light Leaking）现象。</p><h4 id="Screen-Space-Global-Illumination（SSGI）">Screen Space Global Illumination（SSGI）</h4><p>SSGI的思想比较淳朴，渲染完整个屏幕后，将一些反射面看作一个镜面反射，找到出射方向上对应的像素颜色，就视作找到了间接光源。SSGI的具体实现步骤如下，在渲染完成后，从反射面投射多个射线；每条射线进行Ray Marching以类似二分查找的方式根据GBuffer的深度信息（需要Mip-map压缩）找到阻挡光线的点；最后使用该点的颜色作为间接光源。</p><p>常规的Ray Marching算法光线的步长是均匀的，为了更加高效SSGI中对Ray Marching做了一些调整。如果当前的Ray没有检测到被阻挡则下一次循环将以上一次检测距离的两倍进行检测，如果有深度比当前深度小，则向后查找是否漏掉更小的，如果没有则视为找到间接光源的着色点。</p><p>SSGI中还可以存储周围的间接光源信息，以便进行重用，从而加快速度。当然SSGI的缺点很明显，如果一个物体的间接光源不在屏幕范围内，那么就不能被找到，于是一些物体的反射效果就会残缺。</p><h4 id="屏幕空间环境光遮蔽（Screen-Space-Ambient-Occlusion，简称SSAO）">屏幕空间环境光遮蔽（Screen Space Ambient Occlusion，简称SSAO）</h4><p>SSAO通过添加模型内部的阴影体现相互遮挡关系从而达到全局光照的效果。SSAO基于两个假设：所有的材质在进行SSAO计算时均视为漫反射；场景中所有物体接收到的间接光照为指定常量值。其实SSAO就是一个后处理效果，首先向G-Buffer写入Depth、Albedo和顶点位置，再根据G-Buffer中的顶点周围随机放置一些采样点，每个采样点都可以通过投影矩阵获得其深度，将该深度值与G-Buffer中的深度进行比较，如果采样点深度小则采样点可见，反之不可见。据此就能计算出每个顶点的可见性如何，带入SSAO公式即可。</p><p><img src="https://s2.loli.net/2024/07/16/DBr2ZiTuFcJzosg.png" alt="SSAO 采样点示意" title="SSAO 采样点示意"></p><h4 id="浅谈流明（Lumen）">浅谈流明（Lumen）</h4><p>Lumen是UE5使用的全局光照技术，核心思想是使用有向距离场（Signed Distance Field，SDF）描述模型边缘，以此简化Ray Tracing的计算；使用表面缓存（Surface Cache）存储上一帧的光照信息，为下一帧计算Multibounce提供数据。</p><h1>《战神4》中的全局光照系统</h1><p>由于全平台都未找到《战神4》全局光照系统的讲座视频，主要参考资料来自讲座PPT。这部分可能会比较粗糙。</p><p>讲座主要介绍了《战神4》中全局渲染技术的三个部分，分别是GI Volume、Cubemap Normalization和AO[7]。这些技术和其他3A游戏中使用的技术相似，但介绍了一些遇到的问题以及解决方案。下面的一些图片来自讲座PPT和GPA抓帧分析。</p><p>在正式介绍全局光照技术前需要先了解《战神4》的关卡结构。《战神4》是一款线性叙事游戏，在游戏场景加载上采取的是流式加载。即加载玩家所在的场景以及所在场景的前后两个场景，移除之外的所有场景。因此一些光照信息比如一些Probe可以预先烘焙好，在游戏时与场景共同加载。</p><p><img src="https://s2.loli.net/2024/07/16/5uxbhl9g2LtU8wW.jpg" alt="《战神4》关卡管理" title="《战神4》关卡管理"></p><h2 id="全局光照体积-GI-Volumes">全局光照体积 GI Volumes</h2><h3 id="什么是-GI-Volumes">什么是 GI Volumes</h3><p>可以类比Unity中光照探针（Light Probe）。程序会自动以Volume为中心烘培体积内的光照信息（包括直接光照、间接光照等）。</p><h3 id="为什么使用-GI-Volumes">为什么使用 GI Volumes</h3><p>传统制作流程中使用Lightmap记录受到直接光照的物体。Lightmap只与环境有光，不会记录角色的光照信息。Lightmap需要手动维护UV需要手动放置探针。一系列的工作相对繁琐重复。</p><p>使用GI Volumes可以减少人工工作量，将环境和角色联系到一起，能配合场景加载系统工作，且性能优越。</p><h3 id="GI-Volumes-如何工作">GI Volumes 如何工作</h3><p>《战胜4》的关卡编辑器直接在Maya中运行，GI Volumes也需要美术在Maya中手工放置。一般来讲GI Volume每一米左右放置一个就足以满足画面需求，且美术放置后可以自动烘培。GI Volumes将记录体积内地静态间接光源，存入4个3D纹理，纹理使用16位浮点数记录RGB信息和天空可见性，同时存储2波段的球谐函数（Spherical Harmonics，SH）。</p><p>需要说明的是天空环境光和反射信息是分开记录的。分别记录到不同纹理的好处在于，可以结合不同的立方体纹理（天空包围盒）实现相同物体在不同天空下的渲染。</p><p><img src="https://s2.loli.net/2024/07/16/wi9ocjxlZ4KF2pk.jpg" alt="分别记录环境光照与反射信息" title="分别记录环境光照与反射信息"></p><p><img src="https://s2.loli.net/2024/07/16/KM2vxHytZQSkwoY.jpg" alt="可任意更换右侧的立方体纹理" title="可任意更换右侧的立方体纹理"></p><p>一个场景中有多个GI Volume，渲染时会收集相机前方最近的4个GI Volume，同时每个Volume都会事先分配到一个次序，着色器根据GI Volumes的次序依次进行着色。</p><p><img src="https://s2.loli.net/2024/07/16/qzC4aGYnxEQth6k.jpg" alt="GI Volumes的收集" title="GI Volumes的收集"></p><h3 id="GI-Volumes-的问题及解决方法">GI Volumes 的问题及解决方法</h3><p><strong>A．</strong> 当体素体积过大时，体素可能会将一些小物体包含进去，导致自遮蔽和漏光问题（Light Leaking）。<br><strong>B．</strong> 移动的物体会由于小角度的转动导致法线变化剧烈使物体表面闪烁。<br><strong>C．</strong> 对于一些角落模型法线可能比较混乱从而出现漏光。<br><strong>D．</strong> 仅使用的Cubemap的话会导致部分反射发光，这是因为Cubemap的信息没有本地的遮挡关系（Local Occlusion）。</p><p>解决A问题可以将GI采样位置沿物体法线方向偏移一个体素。解决B问题可以在烘培时不对法线进行偏移。解决问题C可以通过额外的GBuffer平滑模型法线。对于问题D需要对立方体纹理进行归一化，用GI对光照信息进行修正。下面将具体讨论Cubemap 的归一化。</p><h2 id="立方体纹理的归一化-Cubemap-Normalization">立方体纹理的归一化 Cubemap Normalization</h2><p>Cubemap仅仅记录了环境的颜色信息，环境中的一些低频光会被球体接受并反射，从而发生上述问题。因此将这部分替换为正确的信息即可。使用GI Volumes的SH移除Cubemap的低频细节，使用GI的低频信息替代，就得到了合理的结果。</p><p><img src="https://s2.loli.net/2024/07/16/LydeQwpWf9B18uU.png" alt="Cubemap Normalization" title="Cubemap Normalization"></p><p><img src="https://s2.loli.net/2024/07/16/XPJUgGfauxqTsmZ.png" alt="Cubemap经过归一化修正后的效果（左为修正前，右为修正后）" title="Cubemap经过归一化修正后的效果（左为修正前，右为修正后）"></p><p>但是归一化的过程可能会出现除0的情况（特别是在球的底部），或者因为场景的不同效果出现差异等问题。下面是一个离散化为N阶球面空间的公式。s是空间分布的一片微小区域，用（球坐标表示），g表示对不同方向上的光照强度进行采样，并与基底函数Yi相乘并累加求和，经过球的表面积平均后可以得到球谐系数ci。为避免SH等于0（或接近0）的情况时出现可以减小在采样Cubemap时的方向性和饱和度。</p><p><img src="https://s2.loli.net/2024/07/16/KZIidfNc1zeB7ho.png" alt="左为修复前，右为修复后的效果" title="左为修复前，右为修复后的效果"></p><h2 id="环境光遮蔽-Ambient-Occlusion">环境光遮蔽 Ambient Occlusion</h2><p>环境光遮蔽部分使用SSAO与AO map、以及环境阴影等技术共同完成。同时还需采样角色的胶囊体以产生角色的阴影。环境阴影采取和《Last Of Us》相同的技术。</p><p><img src="https://s2.loli.net/2024/07/16/4QG5ygH1PacdCYX.png" alt="环境光遮蔽效果" title="环境光遮蔽效果"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏案例分析——技术向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
