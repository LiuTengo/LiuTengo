<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPP中的STL容器</title>
      <link href="/2024/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP%E4%B8%AD%E7%9A%84STL%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP%E4%B8%AD%E7%9A%84STL%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 基础汇总</title>
      <link href="/2024/07/19/C&amp;CPP%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/07/19/C&amp;CPP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>鄙人进入大学后才正式学习编程，加之中国传媒大学的计算机课程安排凌乱结课要求低，因此基础知识仍然不成体系不够扎实。故写一写博客用于输出学到的内容，整理面试时被问到的问题。</p><h1>往期内容</h1><ul><li><a href="/2024/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP%E4%B8%AD%E7%9A%84STL%E5%AE%B9%E5%99%A8/" title="CPP中的STL容器">C++中的STL容器</a></li></ul><h1>参考资料</h1><ul><li>中国传媒大学 《面向对象游戏程序设计》 课程PPT</li><li>中国传媒大学 《游戏开发程序设计基础》 课程PPT</li><li><a href="https://web.stanford.edu/class/cs106l/">斯坦福大学 CS106</a></li><li><a href="https://www.bilibili.com/video/BV1oD4y1h7S3/">Chorno的C++课程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见布料模拟方法 Cloth Simulation</title>
      <link href="/2024/07/17/%E5%B8%B8%E8%A7%81%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95-Cloth-Simulation/"/>
      <url>/2024/07/17/%E5%B8%B8%E8%A7%81%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95-Cloth-Simulation/</url>
      
        <content type="html"><![CDATA[<p>本文整理了布料模拟实践过程中学习到的各种理论方法，记录了实践过程中遇到的问题和解决办法。主要基于Unity完成了基于显示欧拉法和PBD方法的布料模拟，并使用ComputeShader对模拟过程的加速。</p><h1>实现思路</h1><h2 id="思路概述">思路概述</h2><p>计算机图形学中的物理模拟方法可以笼统概括为三个阶段：初始化阶段，物理模拟阶段，更新数据阶段。</p><p>初始化阶段中需要构建物理模型。在开始模拟前需要先理解一块布的结构，一块布中存在结构力、剪切力以及弯曲力（图），根据这一结构特点可构建质点弹簧模型，据此模型计算质点间的相互作用完成模拟。</p><p>物理模拟阶段的具体实现方法很多，分为两个主要流派，分别是基于物理的模拟和非物理的模拟。</p><p>物理模拟方法以欧拉法为主。在质点弹簧系统中，根据胡克定律计算质点间的力，更新质点加速度、速度、位置。欧拉法具体有显示欧拉法、半隐式欧拉法和隐式欧拉法，区别在于显示欧拉法使用t时刻受到的合力更新t+1时刻的位置，隐式欧拉法使用t+1时刻受到的合力更新t+1时刻的位置，半隐式欧拉法结合显示欧拉法和隐式欧拉法，通过t时刻受到的合力更新更新t+1时刻的速度，使用该速度更新t+1时刻的位置。显示欧拉的方程是线性的，隐式欧拉的方程是非线性的。通常来说求解非线性方程，可以使用数值分析，比如将非线性方程转换后可以用牛顿迭代的方法求解最小值，或者使用龙格库塔方法进行求解。从稳定性角度来讲，显示欧拉法是条件稳定的，在时间步长较小时可以保持稳定，但当时间步长增大误差就会累积从而失去稳定性。此外随着模拟时间增加，误差也会累积使得出现模拟错误。隐式欧拉法理论上是无条件稳定的，但由于通常使用线性方式近似求解所以也是条件稳定的，仍需控制时间步长进行才能保证模拟稳定运行。</p><p>非物理模拟方法中常见的有基于位置的动力学模拟方法（Position-Based Dynamics，PBD）。主要思路是通过欧拉法预测下一时刻位置，再施加约束进行修正，PBD方法不仅可以用到布料模拟中，而且可以用到软体模拟等模拟中。作者给出了PBD方法的主要思路和框架，只需要确定约束方程，并将约束方程加入到约束列表中解约束即可。从稳定性方面看，与欧拉法相比PBD方法更为稳定，但也不是无条件稳定的，其稳定性也受迭代次数、时间步长的影响。</p><p>数据更新阶段需要将更新好的位置、速度重新赋给模型顶点，然后绘制图形。</p><h2 id="质点弹簧系统的构建">质点弹簧系统的构建</h2><h3 id="结构化网格">结构化网格</h3><p>结构化的网格手动计算每个顶点的初始位置，构建三角形，以及三角形索引。然后为每个三角形每一条边边构建一个弹簧。在此之前，为了防止重复构建弹簧，需要剔除重复边。</p><h3 id="非结构化网格">非结构化网格</h3><p>非结构化的网格直接读取Mesh中的顶点、三角形索引等数据。再为每个三角形的每一条边构建一条弹簧。同样地为了防止重复构建弹簧，需要剔除重复边。非结构化网格可以用于任意网格的模拟。</p><h2 id="物理模拟过程">物理模拟过程</h2><p>实践中实现了显示欧拉和PBD方法的物理模拟。下面给出伪代码。</p><h3 id="显示欧拉">显示欧拉</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreall vertices i</span><br><span class="line">velocityt+1 = velocityt + dt*at;</span><br><span class="line"> positiont+1 = positiont + dt*velocityt;</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h3 id="PBD方法的物理模拟">PBD方法的物理模拟</h3><p>PBD方法的模拟流程如下：</p><h4 id="高斯-赛德尔迭代法（Gauss-Seidel-Iteration）">高斯-赛德尔迭代法（Gauss-Seidel Iteration）</h4><p>高斯-赛德尔迭代法每次迭代中立即使用求解得到新值进行计算。在模拟中体现为遍历每一条边，通过调整每条边两顶点位置，以及边所属的正方格实现对预测位置的修正。</p><p>问题：如果一个正方形网格中只构建一条剪切弹簧，那么会出现布料向一侧变形的错误结果。这是由于Gauss-Seidel迭代以弹簧顺序进行，调整下一根弹簧后上一根弹簧调整过的顶点也会发生移动。</p><h4 id="雅可比迭代法（Jacobi-Iteration）">雅可比迭代法（Jacobi Iteration）</h4><p>雅可比迭代法又称同时迭代法，通过将线性方程的对角矩阵变换为对角矩阵及其他部分，可在每次迭代中直接求得解。体现在模拟过程中为不再需要预测位置而是直接通过解方程得到模拟位置。雅可比迭代法相比高斯赛德尔方法对并行计算更加友好，且不容易发生布料形变的问题。</p><h1>实现方法</h1><h2 id="数据结构">数据结构</h2><h3 id="显示欧拉-2">显示欧拉</h3><h3 id="Gauss-Seidel">Gauss-Seidel</h3><h3 id="Jacobi">Jacobi</h3><h2 id="布料构建">布料构建</h2><h2 id="布料模拟">布料模拟</h2><h3 id="欧拉法">欧拉法</h3><p>计算位置<br>计算速度<br>碰撞响应</p><h3 id="PBD-Gauss-Seidel">PBD Gauss-Seidel</h3><p>距离约束<br>弯曲约束<br>碰撞约束</p><h3 id="PBD-Jacobi">PBD Jacobi</h3><p>约束方法<br>碰撞响应</p><h2 id="GPU模拟">GPU模拟</h2><h3 id="计算着色器（Compute-Shader）">计算着色器（Compute Shader）</h3><p>DirectX 11、OpenGL 4.3后新增了计算着色器。GPU除了可以进行传统光栅化管线还可以利用GPU的架构进行并行运算，完成后处理效果、粒子系统等功能。Compute Shader是独立于Vertex Shader和Fragment Shader的管线。</p><h3 id="写入冲突与原子操作">写入冲突与原子操作</h3><p>在调用计算着色器中的函数需要在CPU端进行，使用Dispatch()调用计算着色器函数，用户可以指定运行的线程组数量。一个线程组包含多个线程，运行时GPU上的多个线程组就会同时无序运行。如果两个弹簧结构中有同一个顶点的索引，在向该顶点写入数据时可能会有多个线程向同一地址的数据写入的情况，使得写入失败。</p><p>对于这种情况可以考虑原子操作，在CS中对于int和uint类型的数据可以使用一系列InterLock()函数避免该情况，但因为位置、速度等都是三维浮点数就需要做出调整。这里参考了别人的解决方法，大概是将要写入的数据转为uint类型，计入临时Buffer中，最后更新数据阶段再从Buffer中读取。</p><h1>实现框架</h1><p>基于Unity实现，渲染部分由Unity绘制。C#脚本负责初始化数据及设置计算着色器的Buffer，计算着色器负责处理并行</p><h1>效果显示</h1><h2 id="测试设备">测试设备</h2><p>CPU：12th Gen Intel® i9-12900HX<br>GPU: NVIDIA GeForce RTX 3080 Ti</p><h2 id="效果演示">效果演示</h2><p>请移步B站： <a href="https://www.bilibili.com/video/BV1qabLeME4p/">https://www.bilibili.com/video/BV1qabLeME4p/</a></p><h1>未完成的工作</h1><h2 id="未完成布料的自相交">未完成布料的自相交</h2><p>虽然PBD文献中给出了布料自相交的约束公式，但每个顶点需要和每个三角形进行碰撞检测放在GPU上就不好实现。看到了一些方法比如可以用BVH树加快这一过程，但在GPU中构建树又是难度较高的事。因此这部分还没来得及完成。</p><h2 id="未完成在GPU中直接绘制布料">未完成在GPU中直接绘制布料</h2><p>用户可以调用DrawProceduralIndirect()在GPU程序化绘制几何图形，以此节约从GPU读取Buffer数据到CPU这一过程的时间。个人一直掌握不好这个函数的用法，常常绘制出不合预期的图形或根本绘制不出图形。故还没有应用到项目中。要不然在GPU端的模拟帧率还可以继续提升。</p><h1>参考文献及资料</h1><p>[1] Matthias Müller, Heidelberger B, Hennix M, etal. Position Based Dynamics[J]. VRIPHYS, 2006(3).<br>[2] WU L, WU B, YANG Y, etal. A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions[J]. ACM, 2020, 1(1).<br>[3]GAMES103<br>[4] 迭代法求解线性方程 （简单迭代法 雅可比(Jacobi)迭代法 高斯-塞德尔(Gauss-Seidel)迭代法 逐次超松弛(SOR)迭代法） <a href="c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%89%88">数值计算方法</a>_高斯-雅可比-CSDN博客<br>[5] PBD（Position Based Dynamics）学习笔记_pbd算法-CSDN博客<br>[6] wlgys8/GPUClothSimulationLearn: Unity GPU布料物理模拟入门 (<a href="http://github.com">github.com</a>)<br>[7] wlgys8/PBDClothLearn: Cloth Simulation by Position Based Dynamics + Unity Job System (<a href="http://github.com">github.com</a>)<br>[8] Solicey/UnityPBDClothSimulationOnGPU: Cloth simulation based on Position Based Dynamics (PBD) in Unity, using compute shaders (<a href="http://github.com">github.com</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理仿真 </tag>
            
            <tag> 软体模拟 </tag>
            
            <tag> Position Based Dynamics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《战神4》中的图形学技术——风场和植被交互系统</title>
      <link href="/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E9%A3%8E%E5%9C%BA%E5%92%8C%E6%A4%8D%E8%A2%AB%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E9%A3%8E%E5%9C%BA%E5%92%8C%E6%A4%8D%E8%A2%AB%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>简单的风力与植被交互系统</h1><p>一些基础教程通过自定义顶点着色器实现对植被面片模型的顶点扰动。简单的方法是根据时间对一张噪声纹理进行位移和缩放上的变化。依据遮罩纹理限制顶点变化值，再将变化值附加到原先的顶点位置上，从而实现植被的随风摆动效果。</p><p>至于与植被的交互则是需要记录玩家的行动轨迹Render Texture，根据Render Texture的信息对周围植被做出响应。</p><p>当然这只是简单的植被材质的实现。在此基础上可以做到更为复杂且看起来真实的效果。但是仅仅简单的方法不能满足角色挥砍武器等动作与植被的交互。同时这种实现方法的植被很容易就会感到重复，为玩家带来的代入感就会降低。</p><h1>《战神4》中的风力与植被交互系统</h1><h2 id="风场的表达">风场的表达</h2><p>结合上面提到的植被交互系统的优缺点，《战神4》制作组提出了明确的目标，需要清晰展现随时空变化风力的变化以及玩家交互。</p><p>在深入探讨如何表达风前，我们需要对风有更加深刻的认识。风可以看作一个场，这个场将位置映射到风力，风力自然是有大小和方向的矢量，且这个矢量会随着时间和空间变化。从最直观感受上看，生活中同一个位置的不同时刻风的方向和强弱均在发生变化，而同一时刻的不同位置风力自然也会有所区别。</p><p>理解了现实中的风，再来思考游戏中的风是如何表达的就简单了。《战神4》中的风场可以看作由环境风场与可交互风场两部分共同作用而成。环境风场采取和传统意义风场相近的方式来表示，即通过采样噪声纹理（Noise Texture）获取风力的大小与方向，再将数值输入给植被。可交互风场其实是只存在于玩家周围的一个Box Volume，它会跟随玩家并记录角色——包括玩家和敌人——的一系列行为对周围风场的影响。</p><h3 id="环境风场">环境风场</h3><h4 id="生成用于环境风场的噪声纹理">生成用于环境风场的噪声纹理</h4><p>噪声纹理就是用于描述游戏中的环境风场的。常见的噪声算法有Perlin noise、Voronoi noise、Worley noise等。《战神4》制作组设计了一个多层噪声函数（Fractal Noise Function）（图1）。该函数固定不同参数下噪声纹理的缩放和频率，当参数发生变化时通过对数分箱的方式（Logarithmic Binning）（图2）获取其他噪声纹理并按权重融合，于是便得到了一个参数变化时噪声变化相对平缓逼真的效果。</p><p><img src="https://s2.loli.net/2024/07/15/bKBDZNc4Ao6Xu72.png" alt="图1.多层噪声" title="图1.多层噪声"></p><p><img src="https://s2.loli.net/2024/07/15/usiALCUgRYNXfJv.png" alt="图2.Log Binning" title="图2.Log Binning"></p><h4 id="噪声纹理的循环">噪声纹理的循环</h4><p>当我们得到噪声纹理后，还需要获取噪声纹理的信息。如果只是随时间移动纹理，以实现受到风力影响的效果，这样会有效果重复的缺点。为了解决这样的问题《战神4》加入了三个额外的处理。首先在达到纹理边界时重设采样位置，其次是重设采样位置时需要对结果进行融合处理，最后重设采样位置时不再返回初始位置，而是随机生成一个新的位置并以相同方向和速度移动纹理。这样就获得了看起来随机且没有循环的环境风场。</p><h3 id="可交互风场">可交互风场</h3><h4 id="可交互风场的定义">可交互风场的定义</h4><p>《战神4》将其称作Wind Simulation Volume，其本质是一个Box Volume。这个体积会包裹住玩家的周围环境，在这个范围内将玩家的动作信息写入纹理中。在这里可以使用3D纹理或者多张2D纹理，区别在于3D纹理是连续的，多张2D纹理是离散的，《战神4》使用的是多张2D纹理。通过记录体积内xyz轴风力的信息，将纹理做模糊处理后就可以根据记录的信息做对应的反馈了。</p><p><img src="https://s2.loli.net/2024/07/15/u5iEhVnC7SPopLR.jpg" alt="图3. Wind Simulation Volume" title="图3. Wind Simulation Volume"></p><p><img src="https://s2.loli.net/2024/07/15/gBdWASs4ExpLC3H.jpg" alt="图4. 使用纹理记录可交互风场信息" title="图4. 使用纹理记录可交互风场信息"></p><h4 id="影响风场的风力产生器">影响风场的风力产生器</h4><p>下面先解决如何记录信息到纹理的问题。《战神4》定义了三种类型的基础几何体，分别是球体、圆柱体、圆锥体。另外定义了四种风力模式，通过修改这些几何体的旋转、位置再根据风力模式就能获得响应的风力信息。四种模式分别是：直线（Directional）、扩散（Omni）、漩涡（Vortex）、触发（Wake Motor）。直线模式与风力的方向相同，扩散模式以形状中心向四周扩散，漩涡模式围绕形状中心旋转，触发模式就是据速度动态调整风力大小，通常是其他模式叠加起来完成的效果。</p><h2 id="风场作用的对象">风场作用的对象</h2><h3 id="音频">音频</h3><p>音频方面的反馈是通过WWISE音频系统实现的。《战神4》开放了风力速度等参数，音频发射器会接收这些参数，根据WWISE系统的属性实现不同的混音效果，从而实现类似多普勒效应的效果。</p><h3 id="布料">布料</h3><p>虽然这部分的工作并没有应用到最后的发行版中，但却进行了相关的实践工作。具体的实现是每块布料会拿到作用于当前布料的大小，然后将力分配到每个顶点上，再投影到顶点法向量上，最后顶点更新位置。其实本质和布料模拟中的欧拉法大致相近，都是通过分析力然后计算速度更新位置。替代的这一做法是使用预先设定好的布料动画，或者将布料算作网格一类的反馈中。</p><h3 id="粒子">粒子</h3><p>粒子只会受到可交互风场的影响，每个粒子会采样其位置下的风速和风向，每帧计算粒子的冲击力使得风速与粒子速度同步。另外还需要根据风速缩放粒子噪声的扰动参数。</p><h3 id="网格">网格</h3><p>这部分可以从两个方面和五个组件介绍。</p><p><img src="https://s2.loli.net/2024/07/15/WAH2o3xXMCZhyB5.png" alt="图5.美术技术任务分配" title="图5.美术技术任务分配"></p><h4 id="美术部分">美术部分</h4><p>美术的主要职责是提供顶点数据和不同植被的相应参数。</p><h5 id="顶点数据">顶点数据</h5><p>美术需要提供植被的遮罩数据以及面片模型的顶点数据。<br><img src="https://s2.loli.net/2024/07/15/zmiKyNHMQTWFPbG.png" alt="图6.顶点数据" title="图6.顶点数据"></p><h5 id="模型参数">模型参数</h5><p>模型数据则十分繁杂。对非树木类的模型参数有密度（Density）、运动影响因子（Movement Scale）、弯曲（Bend）、拉伸（Stretch）、刚度（Stiffness）、摆动弹力（Sway Spring）、摆动阻尼（Sway Dampen）。对于树木类的模型在此基础上还有树木模式（Tree Mode）、树木弯曲度（Tree Bend）、树木运动影响因子（Tree Movement Scale）、树叶延迟（Tree Leaf Lag）。</p><h4 id="技术部分">技术部分</h4><p>技术部分需要在顶点着色器中处理顶点数据，并根据植被参数进行顶点的偏移。在计算着色器中则需要根据参数和给定的纹理计算不同植物的分布，并通过GPU Instance实例化大量的植被。</p><h5 id="顶点着色器">顶点着色器</h5><p><strong>密度（Density）</strong> 两个密度参数，一个控制高速时的密度，一个作用于低速时的模型形态。</p><p><strong>运动影响因子（Movement Scale）</strong> 距离原始顶点位置的缩放。</p><p><strong>弯曲（Bend）</strong> 控制植被弯曲时的形态。</p><p><strong>拉伸（Stretch）</strong> 拉伸前记录原长，将位移量加到顶点位置上，在线性插值到原长，依次替代了对面片做旋转的复杂运算。拉伸系数影响这一步线性插值的大小。</p><p><strong>刚度（Stiffness）</strong> 与布料中的刚度相同，越高植物看起来越硬。</p><p><strong>摆动弹力（Sway Spring）</strong> 和<strong>摆动阻尼（Sway Dampen）</strong> 决定拉伸回原长时的作用力。</p><p><strong>树木模式（Tree Mode）</strong> 开启则会使树干受到风的影响。</p><p><strong>树木弯曲度（Tree Bend）</strong> 作用同前文的Bend参数，控制树木的弯曲程度。</p><p><strong>树木运动影响因子（Tree Movement Scale）</strong> 作用同前文的Movement Scale参数，控制距离原始顶点位置的缩放。</p><p><strong>树叶延迟（Tree Leaf Lag）</strong> 当树叶停止受到风的作用后，树叶回到原位后还会有些许晃动。当该参数越大晃动时间越长幅度越大。</p><h5 id="计算着色器">计算着色器</h5><p>计算着色器的主要任务就是生成环境风场的噪声纹理，并对其进行采样。主要就是依据前文所述方法进行采样，当采样位置到达纹理边界时，随机更新采样位置的坐标，并融合初始和结束位置的采样结果，以相同的方向和速度改变纹理的偏移量。有时采样点会有多个，于是可以使用Flow Mapping令其它采样点跟随某个采样点共同移动。但当采样点的移动速度不同时会造成明显的视觉错误。这是由于偏移量的改变速度不同造成的重设采样位置时刻不同导致的。解决这一问题是控制不同位移速度的采样点在淡出时的速度使得最终在统一时刻更新采样位置。</p><h5 id="实例化">实例化</h5><p>使用HLSL的DrawIndexInstanced直接绘制植被模型以及人物头发。避免了实时渲染时CPU不断向GPU传输数据的费时过程。</p><h3 id="毛发（头发、皮毛、胡子）">毛发（头发、皮毛、胡子）</h3><p>对于头发来说，给定了几个在角色头皮上的锚点（不是网格顶点），将风力对顶点的偏移量赋给锚点的偏移量，然后再单位化。还有两种方法就是通过对网格顶点的移动实现头发的飘动，或者将前两个方法融合使用。</p><p>对于皮毛来说，大体和头发相近，但在单位化时需要对所有面片模型进行单位化。</p><p>对于胡子来说，一个角色的胡子由多个面片模型组成，不同的面片模型具有不同的参数。在受风力影响时与皮毛是相近的处理过程。</p><h2 id="角色碰撞">角色碰撞</h2><p>《战神4》尝试了多种角色碰撞方案，记录角色行动轨迹，记录双脚轨迹等，但效果都不尽如人意。单纯记录角色行动轨迹会有台阶处的植被没有碰撞却发生碰撞反馈的情况，记录双脚轨迹则十分消耗性能且对翻滚动作没有反馈。于是想到了记录深度和行动轨迹结合的方法。</p><p>一张纹理使用两个通道，一个用于记录当前走过的深度，一个用来记录深度的淡出（图7）。对发生碰撞的草会向碰撞的方向偏移其顶点然后进行单位化，和上面提到的Stretch参数影响植被模型的过程相同。</p><p>对于大型角色和主要角色，碰撞体使用简化的多边形，小型角色使用其原本的网格碰撞体</p><p><img src="https://s2.loli.net/2024/07/15/xMhmpfLCkXn3ISr.jpg" alt="图7.角色运动轨迹纹理示意（右侧白色是淡出深度，红色是实时深度）" title="图7.角色运动轨迹纹理示意（右侧白色是淡出深度，红色是实时深度）"></p><h2 id="性能优化">性能优化</h2><h3 id="LOD">LOD</h3><p>主要介绍了植被的LOD。当植被与摄像机距离远时使用低面片组成的植被，距离近时过渡到高面片的植被模型[9]。</p><p>这里运用了Card Cluster技术，通过程序化的方式构建不同层次细节面片模型。可以将6面的植被模型压缩到了2。构建方法如下：</p><p><strong>A．</strong> 检测空间中所有的面<br><strong>B．</strong> 将距离较近的面投影到同一面上<br><strong>C．</strong> 面积最大且对其他面弯曲最小的面为下一层次的主面<br><strong>D．</strong> 回到A直到面片数达到限制</p><p><img src="https://s2.loli.net/2024/07/15/mtufkeE8HwAGSqI.png" alt="图8.构建面片模型" title="图8.构建面片模型"></p><h3 id="黑边修复">黑边修复</h3><p>通常的做法是在原图像基础上进行扩大模糊。虽然效果很好但速度比较慢，边缘还会有颜色偏差，玩家一般也不会注意到。</p><p>《战神4》选用的方法名为Mip Flooding。首先对纹理做Mip处理直到只有一个像素颜色，并记录这一过程中所有的压缩纹理。然后根据原图的alpha值进行筛选，对小于某一alpha的位置替换为对应的压缩纹理的颜色，得到的是四周经过压缩而中间清晰的纹理。这样的速度快，且压缩得比模糊处理好，占用的空间资源更少。</p><h1>参考资料 References</h1><p>[1] <a href="https://www.bilibili.com/video/BV1DF411H7W6/">SeanFeeley. Interactive Wind and Vegetation in GodofWar[R]. SMS:GDC, 2019.</a><br>[2] Xavier Décoret, Frédo Durand, François X. Sillion, 等. Billboard Clouds for Extreme Model Simplification[J]. HAL Open Science, 2010(1).<br>[3] <a href="https://www.jianshu.com/p/99f4775c93b9">球谐函数、编解码球谐系数，以及对Light Probe的重建和压缩 - 简书 (jianshu.com)</a><br>[4] <a href="https://yangwc.com/2021/06/12/SSR/">高质量实时渲染：实时全局光照 | YangWC’s Blog</a><br>[5] <a href="https://blog.csdn.net/toughbro/article/details/96724936">[gdc19]《战神4》的风力&amp;植被交互系统_战神 gdc分享-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏案例分析——技术向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《战神4》中的图形学技术——全局光照</title>
      <link href="/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"/>
      <url>/2024/07/15/%E3%80%8A%E6%88%98%E7%A5%9E4%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h1>全局光照技术</h1><h2 id="全局光照的定义">全局光照的定义</h2><p>全局光照（Global Illumination，GI）或称间接光照（Indirect Illumination）。GI可以分为直接光照和间接光照两部分，通常要考虑直接受到光源照射的能量和反射光源产生的能量的总和。</p><p>为了更好理解和分析《战神》中的全局光照技术，下面先介绍一下GI的技术发展路线。</p><h2 id="全局光照的技术发展路线">全局光照的技术发展路线</h2><p>在光栅化渲染管线中，我们需要将场景中的模型数据准备好后输入顶点着色器中，经过细分曲面着色器、几何着色器、光栅化、片元着色器等操作拿到输出图像。这一过程中并不涉及间接光照。直到光线追踪技术的出现。</p><p>光线追踪的思想本质就是从屏幕投射一条光线，光线会经过不断的反射、折射直到打到光源，对物体的着色就是在这一过程中不断积分能量并计算渲染方程。</p><h3 id="光线投射（Ray-Casting）">光线投射（Ray Casting）</h3><p>光线投射由Arthur Appel在一篇名为《 Some techniques for shading machine rendering of solids》中提出。这是光线追踪的第一步，需要将屏幕空间转换到世界坐标下，然后以每个像素为起点向场景中发射一条光线，并根据与光线相交的第一个物体表面的能量进行渲染。</p><h3 id="光线追踪（Ray-Tracing）">光线追踪（Ray Tracing）</h3><p>Whitted-Style光线追踪在光线投射的基础上使用了递归式的光线追踪。当光线与材质表面相交时根据不同表面进行计算。例如，如果材质是反射就计算光线的出射光线并发射出射光线继续进行渲染。</p><h3 id="路径追踪（Path-Tracing）">路径追踪（Path Tracing）</h3><p>1986年，Kajiya提出了路径追踪方法[1]。路径追踪在Whitted-Style光线追踪的基础上做了一些调整修改。一个修改是光线的反射不再是简单的计算入射角和出射角，而是考虑一个反射光线组成的半球，对半球进行采样，随机选择可能出射光线继续追踪。另一个改进是当光源为面光源时采用了蒙特卡洛积分的方法计算光线的贡献。另外Kajiya最重要的贡献是建立了渲染方程理论。</p><p>式中，<br>Lo指x位置处具有的总能量<br>Le指x位置处自发光的能量<br>后面的积分表示x位置处接收从w’方向传播来的能量。fr是材质的BRDF公式。</p><p>Kajiya的路径追踪方法已经将直接光照和间接光照考虑进去了，可以说已经实现了全局光照。虽然可以采取KDTree或BVH等加速结构进行光线求交这一过程进行加速，但是当时的方法还只能用在离线渲染上，远远不能达到实时渲染的帧率要求。Kajiya方法的问题主要是在反射光线时采样时随机的，并没有考虑光线的重要性。因此为了结果看起来没有很多噪点除了后处理的方式降噪就只能增加每次采样时的次数。而增加采样次数就会造成投射光线的数量指数级增长，严重拖慢渲染速度。</p><p>所以一些蒙特卡洛Ray Tracing的实践工作主要集中在重要性采样上。一种简单的方法是均匀采样，即光线达到某物体表面后均匀选取该点周围的光场信息，沿对应方向投射光线。但均匀采样很可能恰好略过重要的微小光源，使得结果不正确。更好的方法是使用概率分布函数（Probability Distribution Function，简称PDF）进行重要性采样，选取能量较高且较为集中方向投射光线。</p><h3 id="动态全局光照与流明（Lumen）">动态全局光照与流明（Lumen）</h3><p>以上的GI全部用于离线渲染，为了能够实时进行全局光照的计算，许多图形工作者做出来很多工作。</p><h4 id="Reflective-Shadow-Maps（RSM）">Reflective Shadow Maps（RSM）</h4><p>RSM一定程度上结合了Shadow Map的生成方式和光子映射（Photon Mapping）的思想[2]。主要内容是用一个相机在光源处沿光照方向渲染一张纹理，其记录了光源直接照射某一位置（为了相机移动时方便计算，一般使用世界坐标系）的深度、世界坐标系下的顶点位置、法线、反射通量（flux）等。经过计算可以得出被遮挡物体在其他间接光源作用的接收的能量积分。</p><p><img src="https://s2.loli.net/2024/07/16/mHa5e3dvOGuz6kg.png" alt="RSM示意图" title="RSM示意图"></p><p><img src="https://s2.loli.net/2024/07/16/gIRzcBFTM3aSLks.png" alt="RSM公式" title="RSM公式"></p><p>RSM公式中Φp表示光源辐射通量。</p><p>获取到纹理后还需要对纹理进行采样。当我们将x点投影到xp对应的纹理坐标时记录该点的uv坐标为（s，t），随后以（s，t）为中心r为半径进行采样（实际是在做Cone Tracing，Cone Tracing就是以一跟光线为中心的）。原文选择使用极坐标表示。ξ1、ξ2分别为均匀随机数，则采样像素位置则可以表示为<br>（s+rξ1（sin（2πξ2）），t+rξ2（cos（2πξ1）））</p><p>为了使采样点更加均匀还要再除以ξ12进行修正。在采样数为400左右时便可以得到不错的效果了。</p><p>但是RSM方法也有不少缺陷。首先每个灯光都需要一张RSM进行描述，其次没有考虑到灯光的可见性，当一个RSM中出现其他灯光时会有一些视觉上的错误。</p><h4 id="Light-Propagation-Volumes（LPV）">Light Propagation Volumes（LPV）</h4><p>LPV方法基于光照辐射率在三维空间中沿直线传播且传播过程中辐射率不变[3]。LPV的思想是将三维场景均匀体素化（不是物体体素化），记录每个体素的辐射度（radiance），将其转换为一个二阶的球谐函数。在着色时计算着色点的辐照度（irradiance）。</p><h4 id="Voxelization-Based-Global-Illumination（VXGI）">Voxelization Based Global Illumination（VXGI）</h4><p>VXGI是UE4中使用的实时全局光照技术。另外同样使用体素化思想进行全局光照渲染的方法还有Sparse Voxel Octree Global Illumination（SVOGI）。前者使用Clipmap的方式存储体素，后者使用八叉树存储体素。这两种方法在物体发生变化时都需要重新构建体素，而八叉树的构建或调整是复杂且较为缓慢的，Clipmap的重建调整则相对简单迅速。另一方面，SVOGI使用Mip-map存储体素信息，一些与相机距离较远的体素也存储了较高分辨率的体素信息，而这部分信息很可能是用不到或者很少用到的，就会造成一定的内存浪费。Clipmap在此基础上进行优化，只对中心的光照信息进行Mip-map操作，节约了许多内存空间。可以说VXGI优于SVOGI方法，这里也只介绍VXGI方法。</p><p><img src="https://s2.loli.net/2024/07/16/GdPkt5BqswaxZc9.jpg" alt="Clipmap与Mip-map" title="Clipmap与Mip-map"></p><p>Clipmap在构建时会将三角形投影到xy、xz、yz三个面上，同时记录透明度、颜色、法线、自发光等信息到3D纹理中，对于一个体素包含多个三角形的情况则会取这些三角形属性的平均值。在距离相机较近的位置使用更加精细的体素，在较远的位置使用体积较大的体素。由于近大远小，这些体素看起来大小差距并不大。</p><p><img src="https://s2.loli.net/2024/07/16/loCt6RLizDwFm8x.jpg" alt="VXGI构建好的场景" title="VXGI构建好的场景"></p><p>构建好体素后，使用RSM的方法拿到纹理，收集每个体素接收到的能量。接下来在每一次Bounce时使用Cone Tracing代替单独一根光线的投射。Cone Tracing就是将一根光线换做有一定角度的圆锥。例如，对于一个半球可以使用多个ConeTracing进行概括描述。对于很锐利的高光则可以使用单一的小夹角的Cone进行描述。在实际反射中会根据材质进行数量、角度上的调整。如果材质是漫反射的，则会在半球上分布多个大夹角的Cone，如果是高光，则只使用一个Cone对出射光线进行描述。</p><p><img src="https://s2.loli.net/2024/07/16/Fty73sd1kP5gOIj.png" alt="Cone Tracing" title="Cone Tracing"></p><p>那么替换原先的光线后又应该判断与体素是否发生相交呢？这里使用形似Ray Marching的方法。首先定义一个光锥，记其起始点为C¬o，投射方向为Cd，圆锥体角θ，某时刻光线长度t。<br>则某时刻圆锥底面半径为：r = t⋅tan(θ/2)，假设有一以圆锥底面圆心为中心，r为半径的球，我们需要构建一个与这个球相切的正方体，将整个球包裹在其中。<br>因此正方体边长为：d =2⋅r = 2⋅t⋅tan(θ/2)<br>根据正方体的边长我们就可以计算出需要在哪一层级的纹理进行采样了。<br>level =  log2（d/Vsize）,其中Vsize是Mip-map的最高层数。</p><p><img src="https://s2.loli.net/2024/07/16/c8yhzTvFeUmBaH9.png" alt="Cone Tracing中的光线步进" title="Cone Tracing中的光线步进"></p><p>VXGI也存在一些问题，比如3D纹理的存储浪费资源；以及当大尺寸体素中的物体比较小时则会发生Cone与其相交但光线从中漏过的情况，从而产生漏光（Light Leaking）现象。</p><h4 id="Screen-Space-Global-Illumination（SSGI）">Screen Space Global Illumination（SSGI）</h4><p>SSGI的思想比较淳朴，渲染完整个屏幕后，将一些反射面看作一个镜面反射，找到出射方向上对应的像素颜色，就视作找到了间接光源。SSGI的具体实现步骤如下，在渲染完成后，从反射面投射多个射线；每条射线进行Ray Marching以类似二分查找的方式根据GBuffer的深度信息（需要Mip-map压缩）找到阻挡光线的点；最后使用该点的颜色作为间接光源。</p><p>常规的Ray Marching算法光线的步长是均匀的，为了更加高效SSGI中对Ray Marching做了一些调整。如果当前的Ray没有检测到被阻挡则下一次循环将以上一次检测距离的两倍进行检测，如果有深度比当前深度小，则向后查找是否漏掉更小的，如果没有则视为找到间接光源的着色点。</p><p>SSGI中还可以存储周围的间接光源信息，以便进行重用，从而加快速度。当然SSGI的缺点很明显，如果一个物体的间接光源不在屏幕范围内，那么就不能被找到，于是一些物体的反射效果就会残缺。</p><h4 id="屏幕空间环境光遮蔽（Screen-Space-Ambient-Occlusion，简称SSAO）">屏幕空间环境光遮蔽（Screen Space Ambient Occlusion，简称SSAO）</h4><p>SSAO通过添加模型内部的阴影体现相互遮挡关系从而达到全局光照的效果。SSAO基于两个假设：所有的材质在进行SSAO计算时均视为漫反射；场景中所有物体接收到的间接光照为指定常量值。其实SSAO就是一个后处理效果，首先向G-Buffer写入Depth、Albedo和顶点位置，再根据G-Buffer中的顶点周围随机放置一些采样点，每个采样点都可以通过投影矩阵获得其深度，将该深度值与G-Buffer中的深度进行比较，如果采样点深度小则采样点可见，反之不可见。据此就能计算出每个顶点的可见性如何，带入SSAO公式即可。</p><p><img src="https://s2.loli.net/2024/07/16/DBr2ZiTuFcJzosg.png" alt="SSAO 采样点示意" title="SSAO 采样点示意"></p><h4 id="浅谈流明（Lumen）">浅谈流明（Lumen）</h4><p>Lumen是UE5使用的全局光照技术，核心思想是使用有向距离场（Signed Distance Field，SDF）描述模型边缘，以此简化Ray Tracing的计算；使用表面缓存（Surface Cache）存储上一帧的光照信息，为下一帧计算Multibounce提供数据。</p><h1>《战神4》中的全局光照系统</h1><p>由于全平台都未找到《战神4》全局光照系统的讲座视频，主要参考资料来自讲座PPT。这部分可能会比较粗糙。</p><p>讲座主要介绍了《战神4》中全局渲染技术的三个部分，分别是GI Volume、Cubemap Normalization和AO[7]。这些技术和其他3A游戏中使用的技术相似，但介绍了一些遇到的问题以及解决方案。下面的一些图片来自讲座PPT和GPA抓帧分析。</p><p>在正式介绍全局光照技术前需要先了解《战神4》的关卡结构。《战神4》是一款线性叙事游戏，在游戏场景加载上采取的是流式加载。即加载玩家所在的场景以及所在场景的前后两个场景，移除之外的所有场景。因此一些光照信息比如一些Probe可以预先烘焙好，在游戏时与场景共同加载。</p><p><img src="https://s2.loli.net/2024/07/16/5uxbhl9g2LtU8wW.jpg" alt="《战神4》关卡管理" title="《战神4》关卡管理"></p><h2 id="全局光照体积-GI-Volumes">全局光照体积 GI Volumes</h2><h3 id="什么是-GI-Volumes">什么是 GI Volumes</h3><p>可以类比Unity中光照探针（Light Probe）。程序会自动以Volume为中心烘培体积内的光照信息（包括直接光照、间接光照等）。</p><h3 id="为什么使用-GI-Volumes">为什么使用 GI Volumes</h3><p>传统制作流程中使用Lightmap记录受到直接光照的物体。Lightmap只与环境有光，不会记录角色的光照信息。Lightmap需要手动维护UV需要手动放置探针。一系列的工作相对繁琐重复。</p><p>使用GI Volumes可以减少人工工作量，将环境和角色联系到一起，能配合场景加载系统工作，且性能优越。</p><h3 id="GI-Volumes-如何工作">GI Volumes 如何工作</h3><p>《战胜4》的关卡编辑器直接在Maya中运行，GI Volumes也需要美术在Maya中手工放置。一般来讲GI Volume每一米左右放置一个就足以满足画面需求，且美术放置后可以自动烘培。GI Volumes将记录体积内地静态间接光源，存入4个3D纹理，纹理使用16位浮点数记录RGB信息和天空可见性，同时存储2波段的球谐函数（Spherical Harmonics，SH）。</p><p>需要说明的是天空环境光和反射信息是分开记录的。分别记录到不同纹理的好处在于，可以结合不同的立方体纹理（天空包围盒）实现相同物体在不同天空下的渲染。</p><p><img src="https://s2.loli.net/2024/07/16/wi9ocjxlZ4KF2pk.jpg" alt="分别记录环境光照与反射信息" title="分别记录环境光照与反射信息"></p><p><img src="https://s2.loli.net/2024/07/16/KM2vxHytZQSkwoY.jpg" alt="可任意更换右侧的立方体纹理" title="可任意更换右侧的立方体纹理"></p><p>一个场景中有多个GI Volume，渲染时会收集相机前方最近的4个GI Volume，同时每个Volume都会事先分配到一个次序，着色器根据GI Volumes的次序依次进行着色。</p><p><img src="https://s2.loli.net/2024/07/16/qzC4aGYnxEQth6k.jpg" alt="GI Volumes的收集" title="GI Volumes的收集"></p><h3 id="GI-Volumes-的问题及解决方法">GI Volumes 的问题及解决方法</h3><p><strong>A．</strong> 当体素体积过大时，体素可能会将一些小物体包含进去，导致自遮蔽和漏光问题（Light Leaking）。<br><strong>B．</strong> 移动的物体会由于小角度的转动导致法线变化剧烈使物体表面闪烁。<br><strong>C．</strong> 对于一些角落模型法线可能比较混乱从而出现漏光。<br><strong>D．</strong> 仅使用的Cubemap的话会导致部分反射发光，这是因为Cubemap的信息没有本地的遮挡关系（Local Occlusion）。</p><p>解决A问题可以将GI采样位置沿物体法线方向偏移一个体素。解决B问题可以在烘培时不对法线进行偏移。解决问题C可以通过额外的GBuffer平滑模型法线。对于问题D需要对立方体纹理进行归一化，用GI对光照信息进行修正。下面将具体讨论Cubemap 的归一化。</p><h2 id="立方体纹理的归一化-Cubemap-Normalization">立方体纹理的归一化 Cubemap Normalization</h2><p>Cubemap仅仅记录了环境的颜色信息，环境中的一些低频光会被球体接受并反射，从而发生上述问题。因此将这部分替换为正确的信息即可。使用GI Volumes的SH移除Cubemap的低频细节，使用GI的低频信息替代，就得到了合理的结果。</p><p><img src="https://s2.loli.net/2024/07/16/LydeQwpWf9B18uU.png" alt="Cubemap Normalization" title="Cubemap Normalization"></p><p><img src="https://s2.loli.net/2024/07/16/XPJUgGfauxqTsmZ.png" alt="Cubemap经过归一化修正后的效果（左为修正前，右为修正后）" title="Cubemap经过归一化修正后的效果（左为修正前，右为修正后）"></p><p>但是归一化的过程可能会出现除0的情况（特别是在球的底部），或者因为场景的不同效果出现差异等问题。下面是一个离散化为N阶球面空间的公式。s是空间分布的一片微小区域，用（球坐标表示），g表示对不同方向上的光照强度进行采样，并与基底函数Yi相乘并累加求和，经过球的表面积平均后可以得到球谐系数ci。为避免SH等于0（或接近0）的情况时出现可以减小在采样Cubemap时的方向性和饱和度。</p><p><img src="https://s2.loli.net/2024/07/16/KZIidfNc1zeB7ho.png" alt="左为修复前，右为修复后的效果" title="左为修复前，右为修复后的效果"></p><h2 id="环境光遮蔽-Ambient-Occlusion">环境光遮蔽 Ambient Occlusion</h2><p>环境光遮蔽部分使用SSAO与AO map、以及环境阴影等技术共同完成。同时还需采样角色的胶囊体以产生角色的阴影。环境阴影采取和《Last Of Us》相同的技术。</p><p><img src="https://s2.loli.net/2024/07/16/4QG5ygH1PacdCYX.png" alt="环境光遮蔽效果" title="环境光遮蔽效果"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏案例分析——技术向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
